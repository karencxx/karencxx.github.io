<!DOCTYPE html>
<html lang="">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>整合 | 蘑菇小记</title>
    <link rel="stylesheet" href="/css/breeze.css">
    <script src="/js/toc.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const backToTopButton = document.getElementById('back-to-top');

            // 当页面滚动超过 300px 时显示按钮
            window.onscroll = function() {
                if (document.body.scrollTop > 300 || document.documentElement.scrollTop > 300) {
                backToTopButton.style.display = "block";
                } else {
                backToTopButton.style.display = "none";
                }
            };
            
            // 点击按钮时平滑滚动回顶部
            backToTopButton.addEventListener('click', function() {
                const scrollToTop = function() {
                    const c = document.documentElement.scrollTop || document.body.scrollTop;
                    if (c > 0) {
                    window.requestAnimationFrame(scrollToTop);
                    window.scrollTo(0, c - c / 8);
                    }
                };
                scrollToTop();
            });
        });
        window.isMobile = /mobile|android|iphone|ipad|phone/i.test(navigator.userAgent);
    </script>

    
<meta name="generator" content="Hexo 5.4.2"></head>
    
  <body>
    <div class="container">
      <header class="header-container post-header">
    <div class="title">
        <img src="/images/Icon-leaf.png" class="leaf-icon">
        <a href="/">蘑菇小记</a>
    </div>
    <nav class="nav">
        <ul>
            
                <li><a href="/archives" class="nav-item">Archives</a></li>
            
                <li><a href="/about" class="nav-item">About</a></li>
            
          </ul>
    </nav>
</header>

      <div class="main-content">
        
          

<aside class="post-toc">
    <div class="toc-wrapper collapsed">
  <div class="toc-toggle">
    <span class="toc-toggle-icon"></span>
  </div>
  <div class="toc-content">
    
      <div class="toc-body">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML"><span class="toc-text">HTML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS"><span class="toc-text">CSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript"><span class="toc-text">JavaScript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E5%92%8C%E5%BA%93"><span class="toc-text">框架和库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React"><span class="toc-text">React</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue"><span class="toc-text">Vue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">工程化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8"><span class="toc-text">前端安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%A2%98"><span class="toc-text">代码题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%92%8C%E7%BB%8F%E9%AA%8C%E7%9B%B8%E5%85%B3"><span class="toc-text">项目和经验相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%92%8C%E6%83%85%E6%99%AF%E9%A2%98"><span class="toc-text">行为和情景题</span></a></li></ol>
      </div>
    
  </div>
</div>


</aside>

<article class="post-detail has-toc toc-collapsed">
    <div class="post-title-container">
        <h1 class="post-title">整合</h1>
    </div>
    <div class="post-meta">
        <time datetime="2021-01-19T11:07:27.000Z">2021-01-19</time>
        
        
  </div>
  <div class="post-content">
    

    <h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ol>
<li>HTML5有哪些新特性？</li>
</ol>
<ul>
<li>语义化标签，header、footer、nav、article、section、aside、main、figure、figcaption</li>
<li>表单控件和属性，控件有type=telephone、email、number、color、date、url等，属性有placeholder、required、pattern、autofocus</li>
<li>多媒体元素，audio、video</li>
<li>图形和绘图功能，canvas和svg（可缩放矢量元素）</li>
<li>本地存储，localStorage、sessionStorage</li>
<li>离线缓存manifest</li>
<li>新的API，如websocket、web workers、history API </li>
<li>css3支持</li>
</ul>
<ol start="2">
<li>解释&lt;doctype&gt;标签的作用。<br>用于声明文档类型和版本，确保浏览器按照正常的标准解析和渲染页面，从而保证网页兼容性和一致性<br>标准模式 和 怪异模式（浏览器会以向后兼容的方式解析和渲染网页）</li>
<li>什么是语义化的HTML，为什么重要？<br>是指使用明确含义的标签来描述网页内容的结构和用途，能提供更多的上下文信息，使得浏览器，搜索引擎和开发者能更好地理解和处理网页内容<br>为什么重要？</li>
</ol>
<ul>
<li>提高可访问性，语义化的标签能让屏幕阅读更好地理解和朗读网页内容，利于视障人群访问</li>
<li>改善搜索引擎优化seo，提供更多上下文信息，帮助搜索引擎更准确地理解内容，提升搜索结果排名</li>
<li>带来更好的代码可读性和维护性</li>
<li>确保页面的结构性和一致性，带来更好的用户体验</li>
<li>兼容未来的规范</li>
</ul>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ol>
<li>CSS选择器的优先级是如何计算的？<br> css选择器优先级为 内联样式 &gt; ID选择器 &gt; 类/伪类/属性选择器 &gt; 元素和伪元素选择器 &gt; 通配符选择器/继承 &gt; 全局/默认样式<br> 当!important出现时，将覆盖所有非!important的样式，无论优先级如何<br> 每个选择器类型有不同的权重，优先级按从左到右逐级计算，优先级高的会覆盖优先级低低</li>
<li>什么是CSS预处理器（如Sass、Less），它们的优缺点是什么？<br>是一种编程工具，原理是将类CSS语言通过工具编译成真正可读的CSS<br>优点是提高效率，代码可重用，代码易阅读和维护，也易于调试<br>缺点<ul>
<li>浏览器不能直接识别需要先编译才能使用</li>
<li>编译需要构建成本需要维护</li>
<li>工具依赖，需要特定的工具或插件处理，增加项目配置复杂性</li>
<li>有学习成本</li>
</ul>
</li>
<li>解释一下如何实现页面布局，包括使用浮动布局、定位布局、Flexbox布局和Grid布局。<ul>
<li>浮动布局最早用于实现文字环绕图片的效果，后也被用于多列布局。<ul>
<li>使用float使元素被移出正常文档流</li>
</ul>
</li>
<li>定位布局，使用position属性，有static、relative、absolute、fixed、sticky等值，可以精确控制元素位置</li>
<li>Flexbox布局是CSS3引入的布局模式，可以轻松实现水平垂直居中，等分布局等</li>
<li>Grid布局也是CSS3引入的布局模式，专门用于二维布局，可以同时控制行和列</li>
</ul>
实现布局的一般步骤：<ul>
<li>确定布局结构</li>
<li>编写html结构</li>
<li>应用css样式</li>
<li>调整和优化</li>
<li>测试</li>
</ul>
</li>
</ol>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ol>
<li><p>let、const和var的区别？<br> 在作用域、提升行为和可变性有所不同<br> let和const是块级作用域，会产生变量提升，但由于暂时性死区，在声明前不能被访问到，在块级作用域内只能声明一次，let可以重复赋值，但const在声明时必须赋值且不可再次赋值，如果是对象，那么只是引用地址不变，可以添加新值<br> var的作用域是函数作用域和全局作用域，存在声明提升，可重复声明赋值</p>
</li>
<li><p>什么是闭包，闭包的应用场景有哪些？<br>闭包简单地来说是在函数内定义另一个函数，且这个函数能访问到外部函数的变量，即闭包是一个引用了另一个函数作用域中变量的函数<br>应用场景：常用于回调函数、模拟块级作用域（立即执行函数）、用于数据的隐藏和封装，如创建私有变量和私有函数</p>
</li>
<li><p>解释原型链和继承</p>
<ul>
<li>每个对象都有一个关联对象，也就是原型对象，这个原型对象也有自己的原型，这些对象连接形成一条链条被称为原型链。当访问一个对象的属性和方法，如果没有，就会沿着原型链向上查找直到找到为止</li>
<li>继承是一个对象能获得另一个对象的属性和方法，在JS中通过原型链实现，子类继承自父类的属性和方法</li>
<li>ES5/ES6 的继承除了写法以外还有什么区别？   </li>
</ul>
</li>
<li><p>this关键字的不同绑定规则（箭头函数、方法调用、构造函数等）</p>
<ul>
<li>全局上下文中this指向全局对象，浏览器为window，node中为global</li>
<li>箭头函数没有自己的this，所以它的this就指向它所在上下文的this值<ul>
<li>在定义时绑定，继承自上下文</li>
</ul>
</li>
<li>方法调用的this指向当前调用该方法的对象</li>
<li>使用new调用构造函数时，this绑定到新创建的对象上</li>
<li>显示绑定，如call、apply、bind<ul>
<li>call、apply会立即调用函数</li>
<li>bind会创建一个新函数实例，但不会立即调用</li>
</ul>
</li>
<li>ES6类中的this绑定到新创建的实例上</li>
<li>DOM事件里this指向触发事件的元素</li>
<li>隐式丢失，当从对象中引用方法时可能会丢失this，导致指向全局对象</li>
</ul>
</li>
<li><p>解释异步编程（回调、Promise、async/await）</p>
<ul>
<li>异步编程是一种编程范式，可以在后台执行，使程序在等待某些操作（如文件读取、网络请求或定时器）完成时能够执行其他任务，从而提高效率和响应性</li>
<li>同步是每个操作按顺序执行，如果某个操作需要等待，程序会阻塞，直到该操作完成</li>
<li>实现异步编程的方式<ul>
<li>回调函数callback，通过将一个函数作为参数传递给另一个函数，当异步操作完成后调用该回调函数。该方式简单直观，但有多个异步操作顺序执行时，会出现嵌套过深，代码难以维护</li>
<li>promise是ES6引入的机制，用来传递异步操作的信息。避免了层层嵌套的回调函数，采用链式调用使代码更简洁。但中途无法取消，没有回调函数内部错误就无法得知</li>
<li>async/await是基于Promise的语法糖，async用于声明一个异步函数，await用于等待异步操作完成。代码更清晰、可读性更高。<ul>
<li>相较于promise，错误处理友好（可以用try/catch），调试友好（promise设置断点不友好）</li>
</ul>
</li>
</ul>
</li>
<li>异步编程应用场景：网络请求、文件读写操作、定时器、用户输入或事件如点击、拖拽等</li>
<li>异步执行机制依赖事件循环。<ul>
<li>宏任务：主代码块、setTimeout、setInterval、setImmediate(Node)、requestAnimationFrame()(浏览器)</li>
<li>微任务：promise.then、catch、finally、process.nextTick(Node)</li>
<li>微任务优先级高于宏任务，其中nextTick高于其他微任务，先进先出</li>
<li>执行顺序是一个宏任务，所有微任务，GUI渲染，下一个宏任务</li>
</ul>
</li>
</ul>
</li>
<li><p>请解释一下事件冒泡、事件捕获、事件委托</p>
<ul>
<li>事件冒泡是事件被触发时，首先在目标元素上触发，然后逐级向上传播到文档根元素</li>
<li>事件捕获与事件冒泡相反，事件从文档根元素开始向下传播到目标元素</li>
<li>事件委托则是对大量相似的元素，将事件处理程序放到这组元素的共同祖先上，利用事件冒泡处理事件，通过event.target确定事件真正目标</li>
<li>事件委托能减少事件处理器数量，提高性能；对于动态添加的元素也能触发事件，无需额外绑定</li>
</ul>
</li>
<li><p>你如何跨域共享资源（CORS）？<br>跨域通常出现在ajax请求，跨文档通信，嵌套的跨域资源如图片脚本等<br>JSONP，动态创建script来加载脚本，这种方法可兼容老式服务器但只支持get<br>domain+iframe<br>响应头设置Access-Control-Allow-Origin：* | <origin>允许指定的域名访问资源<br>发送OPTIONS预检请求，询问是否允许其实际请求<br>代理服务器和反向代理，利用了服务器对服务器无同源策略<br>websocket，是HTML5的持久化协议，可建立跨域连接，与postMessage配合使用<br>postMessage跨文档通信</p>
</li>
<li><p>你能解释一下AJAX请求是什么吗？它和Fetch有什么区别？</p>
<ul>
<li>ajax 是在不重新加载整个页面情况下能够与服务器交换数据并更新部分页面的技术<ul>
<li>特点：异步性，使用JS的 XMLHttpRequest 对象 与服务器通信，支持多种数据格式</li>
<li>但配置和调用方式比较混乱，本身也是针对MVC编程</li>
</ul>
</li>
<li>Fetch API是一个获取资源的接口，它基于Promise机制，简化了异步处理，用于替代 XMLHttpRequest<ul>
<li>支持 AbortController 和 AbortSignal 接口来中止请求</li>
<li>只在网络故障或阻止请求时才报错，对响应为404、400、500会被当作成功的请求</li>
<li>不默认携带cookie，需要手动设置credentials: ‘include’</li>
<li>没有办法原生检测请求进度，而xhr可以</li>
</ul>
</li>
<li>两者区别：<ul>
<li>fetch基于promise和原生js的封装，代码简洁；ajax基于回调函数，复杂异步逻辑时容易陷入回调地狱</li>
<li>fetch返回一个promise，直接可以链式调用；ajax需要手动处理readyState和status</li>
<li>fetch默认支持CORS，配置mode选项即可；ajax则需要服务端配合设置允许跨域</li>
<li>fetch支持读取流和处理大文件；ajax则不支持，需要将整个响应加载到内存中</li>
<li>fetch 更现代化，具有更强大的功能更灵活的配置；语法简洁</li>
<li>XMLHttpRuquest更具兼容性更成熟</li>
</ul>
</li>
<li>Axios是基于Promise封装的HTTP客户端，在浏览器端会发起 XMLHttpRequest 请求，在node端发起 http 请求<ul>
<li>监听请求和返回，可以取消请求</li>
<li>自动转化json数据；客户端可以抵御XSRF攻击</li>
</ul>
</li>
</ul>
</li>
<li><p>Object.prototype.toString.call()、instanceof以及Array.isArray()这三者可以判断数组，有什么区别和各自的优缺点</p>
<ul>
<li>Object.prototype.toString.call()可以判断各种内置类型；不同执行环境下都能判断；但语法较长不直观，性能略低</li>
<li>instanceof能够检测对象是否继承自指定构造函数的原型链，确定值的引用类型；但在不同执行环境中可能会失败</li>
<li>Array.isArray()是ES5新增的方法，专门用于检测数组，不能判断其他类型</li>
</ul>
</li>
<li><p>对象创建的几种方式</p>
</li>
<li><p>forEach 和 map 区别（有无返回值）</p>
</li>
<li><p>区别对象和数组的方法</p>
<h3 id="框架和库"><a href="#框架和库" class="headerlink" title="框架和库"></a>框架和库</h3><p>你对前端框架（如React、Angular和Vue）的理解有多深？你能描述一下它们的工作原理吗？</p>
</li>
</ol>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><ol>
<li><p>解释React的虚拟DOM及其工作原理</p>
<ul>
<li>用JS对象来描述DOM结构，实现高效UI更新的一种技术</li>
<li>工作原理<ul>
<li>创建虚拟DOM树</li>
<li>当组件状态或属性发生变化时，调用render生成新的虚拟DOM树</li>
<li>diff算法比较<ul>
<li>react 将 新虚拟DOM树 与 旧的虚拟DOM树进行比较，这个过程称为 reconciliation（协调）</li>
<li>从树根节点开始，比较同级节点，O(n)</li>
<li>只比较同层级节点不跨层比较</li>
<li>两个节点类型相同时，认为是相同的节点，只会比较和更新属性和子节点</li>
<li>两个节点类型不同直接替换旧节点及其子节点</li>
</ul>
</li>
<li>Patch操作应用到真实DOM，只更新变化的部分</li>
</ul>
</li>
<li>运用diff算法高效比较和更新</li>
</ul>
</li>
<li><p>什么是React中的HOC（高阶组件）？</p>
<ul>
<li>是增强函数，接收组件作为参数，返回新组件</li>
<li>实现代码复用，不改变原始组件结构或行为，无侵入性</li>
<li>适用场景<ul>
<li>处理路由或组件的访问权限</li>
<li>数据获取处理</li>
<li>日志记录，错误处理</li>
</ul>
</li>
<li>组件臃肿</li>
<li>使用 HOC 时要注意避免引入不必要的渲染性能问题，因为 HOC 会增加组件的层级</li>
<li>确保 HOC 的参数化和配置化，使其具有更好的灵活性</li>
</ul>
</li>
<li><p>解释React hooks的基本用法及其优势<br>是react16.8推出的新功能，有了它能在函数组件里使用诸如state、各种生命周期等钩子函数的特性</p>
<ul>
<li>常用Hooks<ul>
<li>useState，用于在函数组件中添加状态</li>
<li>useEffect，用于在函数组件中处理副作用</li>
<li>useContext，用于在函数组件中使用上下文</li>
<li>useReducer，用于在函数组件中管理复杂的状态逻辑</li>
<li>useCallback，返回一个memoized回调函数，用于性能优化</li>
<li>useRef，返回一个可变的ref对象，其.current属性被初始化为传递的参数</li>
<li>useLayoutEffect，类似于useEffect，但会在所有DOM变更后同步调用effect</li>
</ul>
</li>
<li>优点<ul>
<li>简化组件结构</li>
<li>逻辑复用</li>
<li>更少的代码</li>
<li>性能优化，useMemo、useCallback </li>
<li>利用函数组件和Hooks避免类组件中的 this 困扰</li>
</ul>
</li>
</ul>
</li>
<li><p>介绍React Fiber架构及其优势</p>
<ul>
<li>是react的新核心算法，旨在提高react性能和灵活性</li>
<li>主要特征<ul>
<li>异步渲染，允许分割渲染工作，可以在多个帧中分批完成更新，从而避免阻塞主线程</li>
<li>优先级调度，实现任务的优先级机制，确保高优先级任务可以打断低优先级的渲染任务，确保用户界面的响应速度</li>
<li>并发模式，允许在后台进行非阻塞的渲染更新</li>
<li>更好的错误处理，提供更细粒度的错误辩解，可以更有效地捕获和处理渲染过程中的国务</li>
</ul>
</li>
<li>优点<ul>
<li>提升用户体验，减少卡顿（异步渲染、优先级调度），快速响应（优先级调度）</li>
<li>提高性能，分片更新，调度优化</li>
<li>更灵活的渲染，并发模式支持，细粒度控制</li>
<li>更好的开发体验，改进的错误边界，兼容旧版本</li>
</ul>
</li>
</ul>
</li>
<li><p>描述一下你对React的生命周期方法的理解，以及在何时会使用它们？</p>
<ul>
<li>挂载阶段<ul>
<li>constructor()，组件构造函数，最先被执行。进行初始state设定和绑定事件处理函数</li>
<li>static getDerivedStateFromProps()，静态方法，会在组件实例化后和接收新的props前被调用</li>
<li>render()，渲染组件到DOM节点</li>
<li>componengDidMount()，组件挂载后立即被调用。进行API调用、数据请求、事件监听等操作</li>
</ul>
</li>
<li>更新阶段<ul>
<li>static getDerivedStateFromProps(nextProps, prevState)，当组件接收到新的props时被调用</li>
<li>shouldComponentUpdate()(scu)，决定组件是否应该更新。进行性能优化，避免不必要的渲染</li>
<li>render()，组件更新时重新渲染</li>
<li>getSnapshotBeforeUpdate()，在DOM调用更新之前调用，可以获取DOM更新前的snapshot快照。在DOM更新前获取一些信息，如滚动位置</li>
<li>componengDidUpdate()，组件更新后立即被调用</li>
</ul>
</li>
<li>卸载阶段<ul>
<li>componengWillUnMount()，组件卸载和销毁前被调用。清理工作，如清除定时器、事件监听</li>
</ul>
</li>
<li>错误阶段<ul>
<li>static getDerivedStateFromError()，当渲染过程、生命周期方法或构造函数中抛出错误时，该方法被调用</li>
<li>componentDidCatch()，捕获子组件错误   </li>
</ul>
</li>
</ul>
</li>
<li><p>你如何优化React应用的性能？有没有使用过React的PureComponent或者shouldComponentUpdate</p>
<ul>
<li>常见的优化策略<ul>
<li>React.PureComponent<ul>
<li>是一个继承自 React.Component 的类，自动实现了 shouldComponentUpdate 生命周期方法，浅比较 prop、 state方法来决定是否需要重新渲染组件</li>
</ul>
</li>
<li>shouldComponentUpdate<ul>
<li>在类组件中使用，提供更细粒度的控制，适合 prop 和 state 是复杂数据类型的组件</li>
</ul>
</li>
<li>函数组件优化 React.memo<ul>
<li>实现类似于 PureComponent 的优化</li>
<li>自动进行浅比较，适合简单数据类型prop</li>
</ul>
</li>
<li>其他优化策略<ul>
<li>不可变数据结构，有助于简化状态更新和比较</li>
<li>避免匿名函数和内联对象，防止不必要的渲染</li>
<li>代码分割和懒加载<ul>
<li>React.lazy，结合&lt;React.Suspence&gt;使用</li>
</ul>
</li>
</ul>
</li>
<li>函数组件中 useMemo、useCallback 缓存计算结果和函数</li>
</ul>
</li>
</ul>
</li>
<li><p>函数式组编程怎么理解</p>
<ul>
<li>是一种编程范式，与面向对象编程相比，它强调无副作用的函数和不可变性</li>
<li>数组的方法如split、join、map就有纯函数的特点</li>
<li>核心概念<ul>
<li>纯函数，总是产生相同输出，不产生副作用<ul>
<li>例如函数不能包含new Date()或Math.random()等这种不可控的因素</li>
</ul>
</li>
<li>数据一旦被创建，就不可变；不修改参数<ul>
<li>保证数据稳定性，避免依赖的数据被未知地修改，引起自身执行异常</li>
</ul>
</li>
<li>高阶函数指接收一个或多个函数作为参数，返回一个函数的函数</li>
<li>函数组合，将多个函数组合为一个新函数，可以一个接一个执行</li>
<li>柯里化，将多个参数转换一系列只接收单个参数的函数</li>
<li>递归</li>
<li>鼓励将副作用隔离开（如修改全局变量、输入/输出等）</li>
<li>不变数据结构，避免产生复杂的副作用</li>
<li>惰性评估，当需要结果时才计算表达式的值</li>
</ul>
</li>
<li>优势<ul>
<li>完全独立，与外部解耦</li>
<li>由于纯函数和不可变性，更易于理解和推理</li>
<li>避免共享状态更适合并发和并行执行</li>
<li>高阶函数和函数组合可以提高代码复用性</li>
<li>纯函数没有副作用，更易编写单元测试</li>
</ul>
</li>
<li>缺点<ul>
<li>不可变性和递归可能导致性能问题，尤其是在处理大量数据时</li>
<li>有一定学习成本</li>
</ul>
</li>
</ul>
</li>
<li><p>你如何看待React, Angular和Vue的优缺点？你会在什么场景下选择这些框架？</p>
</li>
<li><p> 你有没有使用过Redux或者Vuex进行状态管理？你如何看待它们的优缺点？</p>
</li>
<li><p>你有没有使用过React Native或者Vue Native进行移动端开发？你对它们的理解有多深？</p>
</li>
<li><p>你对前端路由有什么理解？你有没有使用过React Router或者Vue Router？</p>
</li>
</ol>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><ol>
<li><p>Vue生命周期钩子有哪些，分别在什么时候触发？它们的作用是什么？<br>beforeCreate，在实例初始化后，<br>created，实例创建完成后，初始化注入和初始化打他、props等数据属性后，但未挂载到DOM上<br>beforeMount，挂载开始前被调用，相关render函数首次被调用，VDOM创建完成未渲染<br>mounted，实例挂载后调用，真实DOM已渲染完成<br>beforeUpdate，响应数据更新时调用<br>updated，数据变化时虚拟DOM重新渲染和打补丁之后调用<br>beforeDestroy，实例销毁之前调用，执行一些清理工作（删除节点、watcher依赖、清除定时器、取消事件监听等）<br>destroyed，实例销毁后调用，执行一些最终清理工作</p>
</li>
<li><p>解释Vue中的双向数据绑定及其实现原理<br>是一种数据同步机制<br>实现双向数据绑定主要依赖v-model指令和响应式系统<br>当数据改变会自动更新视图，在视图中的操作也会更新到数据模型上<br>而响应式则是双向数据绑定到基础，主要通过数据劫持和观察者模式来实现<br>分几个步骤：<br>1、数据劫持，通过Object.defineProperty来拦截对象属性的get、set方法来监听数据的变化<br>2、观察者模式<br>   3、 订阅依赖并追踪<br>   4、 更新视图，数据变化时通知所有依赖数据的视图更新</p>
</li>
</ol>
<p>当用户在视图中修改数据（例如通过输入框输入文本）时，v-model 会监听 input 事件，并将输入值更新到对应的数据属性中</p>
<ol start="3">
<li><p>什么是Vue的计算属性和侦听属性, 有何区别？<br>两者都用来响应数据变化的机制</p>
<ul>
<li>计算属性是基于依赖进行缓存，当依赖发生改变时才会重新求值，在计算结果复杂或频繁时性能优于侦听属性</li>
<li>侦听属性是当特定数据变化时执行异步或开销较大的操作的机制，可以深度监听，不缓存，每次变化都执行回调函数，性能上可能不如计算属性</li>
</ul>
</li>
<li><p>什么是 Virtual DOM？Vue.js 如何利用 Virtual DOM 提高性能？<br>虚拟DOM树，用原生JS对象来描述DOM结构，是对真实DOM的抽象描述<br>工作原理：</p>
<ul>
<li>创建VDOM</li>
<li>修改VDOM</li>
<li>比较VDOM，采用diff算法比较新旧两个虚拟DOM树的差异</li>
<li>更新真实DOM，根据diff结果，找出需要更新的地方，patch到真实DOM上<br>如何提高性能：</li>
<li>虚拟DOM在内存中进行计算和比较，减少对真实DOM的操作</li>
<li>批量处理DOM更新，较少重排重绘次数，提高渲染性能</li>
<li>只更新实际变化的部分</li>
<li>跨平台渲染</li>
</ul>
</li>
<li><p>Vue.js 中的组件通信方式有哪些？请分别描述它们</p>
<ul>
<li>父子组件间使用props、this.$emit</li>
<li>自定义组件使用 $on / $off / $emit</li>
<li>vuex</li>
<li>provide / inject</li>
<li>eventbus 事件中心</li>
<li>slot</li>
<li>v-models</li>
</ul>
</li>
<li><p>Vue.js 中的路由是如何实现的？请简要描述 Vue Router 的工作原理</p>
<ul>
<li>监听路由变化</li>
<li>将路由映射到对应到路由配置</li>
<li>根据配置渲染相应的组件</li>
<li>通过 router-view 展示当前组件</li>
<li>允许通过编程式导航控制路由跳转</li>
</ul>
</li>
<li><p>Vuex 是什么？它解决了什么问题？</p>
<ul>
<li>是vue的状态管理库</li>
<li>用于集中式管理应用中组件的状态</li>
<li>解决了多个组件间共享状态、状态复杂度增加的问题</li>
</ul>
</li>
<li><p>Vue.js 的响应式原理是怎样的？Vue.js 中的 v-model 指令的原理是什么？<br>基于 数据劫持 和 观察者模式 </p>
</li>
<li><p> 你在Vue中如何实现组件的复用？</p>
</li>
</ol>
<ul>
<li>将组件封装为但文件组件，在需要的地方引入和使用</li>
<li>使用插槽在组件中灵活分发内容，从而实现复用</li>
<li>Vue 3<ul>
<li>使用Composition API，可以将逻辑提取到可复用的函数中</li>
<li>利用高阶组件HOC，通过包裹原组件实现功能的扩展和复用</li>
<li>组件通过extends继承</li>
</ul>
</li>
</ul>
<ol start="10">
<li><p>Vue.js 中的 mixin 是什么？它的优缺点是什么？</p>
<ul>
<li>是一种可重用的组件配置，允许在多个组件中共享相同的选项</li>
<li>可以包含多种组件选项，当组件使用mixin时，这些选项被合并到组件选项里（data、computed、methods、created…、watch、provide…</li>
<li>优点<ul>
<li>提高代码重用性；组织结构，将组件结构组织成更小、更易管理单元的方式；功能模块化便于维护；将某些功能从组件解耦，使得组件变简洁</li>
</ul>
</li>
<li>缺点<ul>
<li>可能会使得追踪数据来源或方法调用更加困难；合并选项时可能会导致一些不可预见的行为，不易维护；变量来源不明确不利于阅读；过度使用会导致代码复杂性增加；多个mixin会造成命名冲突</li>
</ul>
</li>
</ul>
</li>
<li><p>Vue.js 中的插槽（slot）是如何工作的？</p>
<ul>
<li>将自定义内容插入到组件指定位置</li>
<li>vue2是通过编译成with语句来实现，内容被包裹在一个with语句中，创建了一个新的作用域</li>
<li>vue3则是用函数作用域来处理插槽，减少了作用域污染</li>
<li>工作原理<ul>
<li>模版解析，识别slot标签，并在生成的虚拟DOM中保留位置</li>
<li>父子组件通信，通过插槽内容将数据或模板传递到子组件，子组件渲染时会将内容插入到插槽占位符到位置</li>
<li>虚拟DOM创建与更新</li>
</ul>
</li>
</ul>
</li>
<li><p>Vue.js 的过渡效果是如何实现的？</p>
<ul>
<li>使用<transition> 包裹元素到组件，是一个抽象组件，实际不渲染DOM元素</li>
<li>CSS类 v-(enter | leave)/-active/-to</li>
<li>可以应用在元素进入或离开DOM时触发CSS动画或JS钩子函数<br>如何实现：</li>
<li>将元素包裹在transition或一组元素包裹在transition-group中</li>
<li>使用v-if、v-show、v-for来控制元素显示或隐藏</li>
<li>使用 CSS 类定义进入、离开和更新的过渡效果</li>
<li>利用过渡钩子函数添加或删除CSS类，或执行JS动画</li>
</ul>
</li>
<li><p>Vue.js 的指令是什么？举例说明几个常用的指令及其作用</p>
</li>
</ol>
<ul>
<li>指令是带v-前缀的特性，用于在DOM元素上添加特殊行为</li>
<li>v-model 数据绑定</li>
<li>v-for 列表渲染</li>
<li>v-bind 绑定属性</li>
<li>v-if、v-else 条件判断</li>
<li>v-on 事件绑定</li>
</ul>
<ol start="14">
<li>Vue.js 中的指令和过滤器有何异同？<br>都是用来对数据进行处理和展示，两者都是响应式的<br>但在使用场景和工作方式上有所不同</li>
</ol>
<ul>
<li>指令用于为DOM元素添加特殊行为，带v-前缀。可以操作或改变DOM</li>
<li>过滤器是纯函数，不操作DOM。主要用于处理模版中文本格式</li>
<li>指令可以实现更复杂的逻辑，过滤器主要用于数据格式化和转换</li>
<li>vue提供了一系列内置指令，但过滤器需要自定义</li>
</ul>
<ol start="15">
<li>Vue.js 中的 key 属性有什么作用？</li>
</ol>
<ul>
<li>为每个渲染元素提供唯一标识</li>
<li>能让vue准确地跟踪每个节点的身份</li>
<li>快速识别新旧元素，正确更新组件状态，复用DOM元素，实现就地更新</li>
<li>避免重复渲染和渲染错误</li>
</ul>
<ol start="16">
<li>h函数 _createVNode 做的事情有<br>标准化 props class<br>给 VNode 打上编码标记<br>创建 VNode<br>标准化子节点</li>
</ol>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol>
<li>前端性能优化有哪些常见的方法？</li>
<li>什么是关键渲染路径（Critical Rendering Path）？</li>
<li>如何减少重排和重绘？<ul>
<li>批量更新</li>
<li>fragment</li>
</ul>
</li>
<li>解释Lazy Load及其实现方法。</li>
</ol>
<h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><ol>
<li>解释webpack的工作原理及其基本配置。</li>
<li>什么是Tree Shaking？</li>
<li>如何配置和使用Babel？</li>
<li>什么是CI/CD，如何在前端项目中实现？ </li>
<li>你有使用过哪些JavaScript框架或库，如React、Angular或Vue？你对这些有什么看法？</li>
</ol>
<h3 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h3><ol>
<li>什么是XSS（跨站脚本攻击），如何防御？</li>
<li>什么是CSRF（跨站请求伪造），如何防御？</li>
<li>如何防止点击劫持（Clickjacking）？</li>
</ol>
<h3 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h3><ol>
<li>实现一个深拷贝函数。</li>
<li>写一个手写的Promise实现。</li>
<li>模拟实现new关键字的行为。<br>function O(o) {<br>   let F = function(){}<br>   o.prototype = F<br>   return new o<br>}</li>
<li>实现一个简单的HTTP请求。</li>
<li>写一个函数来反转一个字符串。</li>
<li>写一个函数来检查一个字符串是否是回文（即正读和反读都一样的词或句子）。</li>
<li>写一个函数来将驼峰命名法（camelCase）的字符串转换为破折号命名（kebab-case）。</li>
<li>写一个函数来查找数组中的最大值和最小值。</li>
<li> 创建一个能够深度复制对象的函数。</li>
<li>写一个函数，将两个数组合并并删除重复项。</li>
<li>写一个函数，实现一个基本的计算器，能够进行加、减、乘、除运算。</li>
<li>创建一个函数，实现简单的事件监听器。</li>
<li>创建一个函数，它可以创建一系列的累加器。每个新创建的累加器都会记住它自己的初始值，并且可以对这个初始值进行累加操作。</li>
<li>创建一个函数，它可以生成一系列的唯一ID。每次调用该函数，都会返回一个新的唯一ID。</li>
<li>创建一个函数，它可以“记住”之前被调用的结果。如果再次用相同的参数调用该函数，它将不会重新计算，而是直接返回之前记住的结果</li>
<li>[1,2,3].map(parseInt) [10,10,10,10,10].map(parseInt)<ul>
<li>map 传递3个参数：元素、索引、数组</li>
<li>parseInt(string, radix)</li>
<li>这里 parseInt 会忽略第三个参数，但不会忽略第二个参数</li>
<li>实际执行代码：parseInt(string, radix) -&gt; map(parseInt(value, index))</li>
<li>可以改为 .map(Number)</li>
<li>变形题<br>let unary = fn =&gt; val =&gt; fn(val)<br>let parse = unary(parseInt)<br>[‘1.1’, ‘2’, ‘0.3’].map(parse)</li>
</ul>
</li>
<li><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="title function_">resolve</span>(p1))</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p1)</span><br><span class="line"><span class="keyword">const</span> p4 = p2.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="title function_">resolve</span>(p3)))</span><br><span class="line"><span class="keyword">const</span> p5 = p4.<span class="title function_">then</span>(<span class="function">() =&gt;</span> p4)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 == p2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 == p3)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3 == p4)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p4 == p5)</span><br></pre></td></tr></table></figure>
<h3 id="项目和经验相关"><a href="#项目和经验相关" class="headerlink" title="项目和经验相关"></a>项目和经验相关</h3></li>
<li>介绍一下你最有挑战性的一个项目。</li>
<li>你在项目中是如何进行状态管理的？</li>
<li>你如何进行代码的版本控制和团队协作？</li>
<li>你有没有使用过版本控制系统，如Git？你如何处理合并冲突？<br>你如何优化网页性能？请描述你在过去的项目中是如何提高页面加载速度和运行效率的。</li>
<li>描述一下你在大型项目中如何组织和管理你的JavaScript代码？</li>
<li>你如何处理浏览器间的兼容性问题？你可以给出一些具体的例子吗？</li>
<li>描述一下你如何进行代码审查？你在审查代码时主要关注哪些方面？</li>
</ol>
<h3 id="行为和情景题"><a href="#行为和情景题" class="headerlink" title="行为和情景题"></a>行为和情景题</h3><ol>
<li>你是如何学习和掌握新的前端技术的？</li>
<li>遇到项目中出现重大bug时，你是如何处理的？</li>
<li>你如何处理与后端同事的合作问题？</li>
<li>如果给你设计实现一个框架，需要考虑哪些方面问题，怎么去解决</li>
<li>你如何对网站的文件和资源进行优化？</li>
</ol>

  </div>
</article>

        
        
      </div>
      <footer class="footer">
    <div class="footer-content">
        <p>&copy; 2025 蘑菇小记</p>
        <p class="copyright">All rights reserved.</p>
    </div>
</footer>
    </div>
    <button id="back-to-top" title="回到顶部">↑</button>
  </body>
</html>

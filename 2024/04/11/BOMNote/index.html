<!DOCTYPE html>
<html lang="">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BOMNote | 蘑菇小记</title>
    <link rel="stylesheet" href="/css/breeze.css">
    <script src="/js/toc.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const backToTopButton = document.getElementById('back-to-top');

            // 当页面滚动超过 300px 时显示按钮
            window.onscroll = function() {
                if (document.body.scrollTop > 300 || document.documentElement.scrollTop > 300) {
                backToTopButton.style.display = "block";
                } else {
                backToTopButton.style.display = "none";
                }
            };
            
            // 点击按钮时平滑滚动回顶部
            backToTopButton.addEventListener('click', function() {
                const scrollToTop = function() {
                    const c = document.documentElement.scrollTop || document.body.scrollTop;
                    if (c > 0) {
                    window.requestAnimationFrame(scrollToTop);
                    window.scrollTo(0, c - c / 8);
                    }
                };
                scrollToTop();
            });
        });
        window.isMobile = /mobile|android|iphone|ipad|phone/i.test(navigator.userAgent);
    </script>

    
<meta name="generator" content="Hexo 5.4.2"></head>
    
  <body>
    <div class="container">
      <header class="header-container post-header">
    <div class="title">
        <img src="/images/Icon-leaf.png" class="leaf-icon">
        <a href="/">蘑菇小记</a>
    </div>
    <nav class="nav">
        <ul>
            
                <li><a href="/archives" class="nav-item">Archives</a></li>
            
                <li><a href="/about" class="nav-item">About</a></li>
            
          </ul>
    </nav>
</header>

      <div class="main-content">
        
          

<aside class="post-toc">
    <div class="toc-wrapper collapsed">
  <div class="toc-toggle">
    <span class="toc-toggle-icon"></span>
  </div>
  <div class="toc-content">
    
      <div class="toc-body">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="toc-text">计算机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOM"><span class="toc-text">BOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84"><span class="toc-text">浏览器架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%8E%92%E9%87%8D%E7%BB%98"><span class="toc-text">重排重绘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URL%E5%88%B0%E5%B1%95%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">在浏览器中输入URL到展示的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-HTTPS"><span class="toc-text">HTTP &#x2F; HTTPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6Event-Loop"><span class="toc-text">事件循环机制Event Loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6"><span class="toc-text">存储机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-text">跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node%E7%9A%84Event-Loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">Node的Event Loop事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%EF%BC%8C%E7%94%A8%E4%BA%8E%E4%BF%9D%E6%8A%A4%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E7%9A%84%E9%9A%90%E7%A7%81%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">数据脱敏，用于保护敏感数据的隐私和安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-text">HTTP请求方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">常见状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-text">进程、线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">JS为什么是单线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-worker%EF%BC%8C%E6%98%AFHTML5%E6%8F%90%E4%BE%9B%E7%9A%84JS%E7%BA%BF%E7%A8%8B"><span class="toc-text">web worker，是HTML5提供的JS线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E8%AE%AF"><span class="toc-text">跨标签页通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E3%80%81%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-text">事件冒泡、事件捕获、事件委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout-0-%E4%BC%9A%E7%AB%8B%E5%8D%B3%E8%BE%93%E5%87%BA%E5%90%97"><span class="toc-text">setTimeout(0) 会立即输出吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E8%B0%83%E7%94%A8setTimeout-%E9%97%B4%E6%AD%87%E8%B0%83%E7%94%A8setInterval"><span class="toc-text">超时调用setTimeout() 间歇调用setInterval()</span></a></li></ol>
      </div>
    
  </div>
</div>


</aside>

<article class="post-detail has-toc toc-collapsed">
    <div class="post-title-container">
        <h1 class="post-title">BOMNote</h1>
    </div>
    <div class="post-meta">
        <time datetime="2024-04-11T13:28:04.000Z">2024-04-11</time>
        
          <div class="post-tags">
            
              <a href="/tags/%E5%A4%8D%E4%B9%A0/" class="post-tag">复习</a>
            
          </div>
        
        
          <div class="post-categories">
            
              <a href="/categories/BOM/" class="post-category">BOM</a>
            
          </div>
        
  </div>
  <div class="post-content">
    

    <p>开始前，可以先看以下几篇</p>
<ol>
<li><a href="/2021/03/01/js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">js运行机制</a></li>
<li><a href="/2021/01/05/%E8%B7%A8%E5%9F%9F">跨域</a></li>
<li><a href="/2021/03/11/%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8%E6%80%BB%E7%BB%93">前端存储总结</a></li>
<li><a href="/2024/04/07/JS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">JS内存管理</a></li>
</ol>
<blockquote>
<h3 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h3></blockquote>
<ul>
<li>CPU(central processing unit) 中央处理器</li>
<li>GPU(graphics processing unit) 图形处理器</li>
</ul>
<p><strong>体系结构</strong></p>
<ul>
<li>底部：机器硬件</li>
<li>中间：机器硬件</li>
<li>顶部：应用程序</li>
</ul>
<blockquote>
<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3></blockquote>
<ul>
<li>核心对象：window，表示浏览器的一个实例，是ECMAScript规定的Global对象</li>
<li>在全局作用域中声明的变量、函数都会变成window对象的属性和方法</li>
<li>全局变量(使用var、let或const关键字声明)不能被delete删除，定义在window上的属性可以被delete<ul>
<li>var声明的全局变量在window对象上可见，而let、const声明的全局变量不会被添加到window对象上</li>
</ul>
</li>
<li>通过查询window对象，可知道某个未声明的变量是否存在</li>
</ul>
<hr>
<p><strong>框架&lt;frames&gt;&lt;/frames&gt;</strong></p>
<ul>
<li>每个框架都有自己的window对象，存在frames集合中</li>
<li>确定窗口位置 screenLeft / screenTop / moveTo() / moveBy()</li>
<li>窗口大小 innerHeight / innerWidth / outerWidth / outerHeight<ul>
<li>不同浏览器会有区别。inner返回视图区大小；outer可能返回浏览器窗口本身大小</li>
<li>document.(documentElement / body).clientWidth / clientHeight</li>
</ul>
</li>
<li>调整浏览器窗口大小 resizeTo() resizeBy()</li>
<li>对话框 alert() confirm() prompt()</li>
</ul>
<hr>
<p><strong>导航</strong></p>
<ul>
<li>window.open(URL，窗口目标，一个特性字符串，是否取代浏览器当前页布尔值)<ul>
<li>例：URL，_self / _blank，’height=400,width=400’</li>
</ul>
</li>
<li>var wroxwin = window.open(…)，通过wroxwin == null判断窗口是否</li>
</ul>
<hr>
<p><strong>location</strong></p>
<ul>
<li>location.search / host / hash / href / pathname / port / hostname</li>
<li>location.assign() 打开新URL并生成一条记录</li>
<li>location.replace() 替换当前页面，不会生成新记录，不能回到前一个页面</li>
<li>location.reload() 重新加载（可能从缓存中） 传入true表示从服务器重新加载</li>
</ul>
<hr>
<p><strong>screen对象</strong></p>
<ul>
<li>窗口外部显示器信息 screen.height / width</li>
</ul>
<hr>
<p><strong>history</strong></p>
<ul>
<li>history.go(整数值) 负数表示后退，正数表示前进</li>
<li>history.back() history.forward()</li>
</ul>
<hr>
<p><strong>navigator</strong></p>
<ul>
<li>检测显示网页的浏览器类型</li>
</ul>
<hr>
<blockquote>
<h3 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h3></blockquote>
<ul>
<li>用户界面UI，包括浏览器地址栏、工具栏等可见部分。主要与用户进行交互，接受用户输入并展示信息。</li>
<li>浏览器引擎</li>
<li>渲染引擎，核心是将HTML、CSS和JS三者转成可视内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GUI渲染线程：解析HTML、CSS，构建DOM树和CSSOM树</span><br><span class="line">JS引擎线程：负责解析和执行JS代码，是单线程</span><br><span class="line">事件触发线程：用来控制事件循环，只关心异步回调</span><br><span class="line">异步http线程：XMLHttpRequest用于处理AJAX请求</span><br><span class="line">定时器线程：管理setTimeout / setInterval这两个定时器</span><br><span class="line">    * 只管理定时器不关心结果，结果在事件触发线程中</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">渲染进程内部包含主线程、工作线程、合成线程和光栅线程</span><br><span class="line">每个Tab页面都有一个渲染进程，互不影响</span><br><span class="line">JS可以操作DOM，如果JS线程跟GUI线程同时运行，那渲染线程前后获得的元素可能会不一致</span><br><span class="line">    * GUI渲染引擎与JS引擎互斥</span><br><span class="line">    * 当JS引擎执行时GUI会被挂起（可以认为被冻结）等JS引擎空闲时再执行</span><br></pre></td></tr></table></figure></li>
<li>后端服务层<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">网络层，负责处理网络请求和响应</span><br><span class="line">存储层，浏览器的本地存储机制</span><br><span class="line">安全层，负责保护用户隐私和安全</span><br></pre></td></tr></table></figure></li>
<li>扩展功能，包括允许用户安装的扩展程序</li>
</ul>
<hr>
<blockquote>
<p>新开一个窗口时，打开浏览器的任务管理器能看到什么</p>
</blockquote>
<ul>
<li>浏览器主进程</li>
<li>GPU进程</li>
<li>多个渲染进程</li>
<li>网络进程</li>
<li>存储进程</li>
<li>音频进程</li>
<li>多个扩展程序</li>
</ul>
<hr>
<blockquote>
<p>浏览器多进程架构的好处</p>
</blockquote>
<p><u>都由独立的渲染器进程运行，相互不干扰</u></p>
<p>安全性增强 / 稳定性提高 / 隐私保护 / 性能有所优化 / 资源管理</p>
<hr>
<blockquote>
<h3 id="重排重绘"><a href="#重排重绘" class="headerlink" title="重排重绘"></a>重排重绘</h3></blockquote>
<p><strong>repaint 重绘</strong><br>当元素样式改变不影响布局时，浏览器将使用重绘对元素进行更新，此时只需要UI层面的重新绘制，<strong>损耗较少</strong></p>
<ul>
<li>只更改样式</li>
<li>隐藏元素：v-show / visibility: hidden</li>
</ul>
<hr>
<p><strong>reflow 回流/重排</strong><br>当元素尺寸、结构或触发某些属性时，浏览器会重新渲染页面，此时浏览器需重新计算，计算后还需重新布局页面</p>
<ul>
<li>页面初次渲染</li>
<li>浏览器窗口大小改变</li>
<li>元素尺寸、位置、内容改变 （v-if / 删除或添加可见的dom元素）</li>
<li>元素字体大小改变</li>
<li>激活css伪类 :hover</li>
<li>某些属性或调用某些方法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.body.clientWidth / Height | clientTop / Left 元素内部的宽度/高度</span><br><span class="line">offsetWidth/Height | offsetTop/Left 元素的布局宽度/高度</span><br><span class="line">scrollWidth/Height | scrollTop/Left 元素内容宽度的一种度量，包括由于overflow溢出而在屏幕上不可见的内容。</span><br><span class="line">getComputedStyle() 报告元素的所有CSS属性的值</span><br><span class="line">getBoundingClientRect() 元素的大小及其相对于视口的位置</span><br><span class="line">scrollTo()</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>回流必定触发重绘，反之不一定</strong><br><strong>重绘开销小，回流代价大</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">visibility: hidden vs display: none</span><br><span class="line">  display: none 不占用空间，引发重排重绘</span><br><span class="line">  而visibility: hidden 使元素不可见，但仍占用空间且位置没有变化，只引发重绘</span><br></pre></td></tr></table></figure>

<ul>
<li><p>javascript方面</p>
<ul>
<li>减少DOM操作，将多次合并为一次操作；缓存DOM引用避免在循环中频繁查询DOM</li>
<li>尽量使用class进行样式修改而不是内联样式减少重排次数</li>
<li>避免触发同步布局如offsetWidth、scrollTop等引发同步计算导致频繁重排（读写分离，先取值element.offsetWidth再赋给style.width）</li>
<li>使用一些css3特性加速GPU（transform、opacity）</li>
<li>使用虚拟DOM管理和优化DOM操作</li>
<li>动画优化使用requestAnimationFrame API来渲染</li>
<li>避免写出深层嵌套和复杂选择器的css</li>
<li>使用will-change提示浏览器哪些元素将改变来优化元素渲染（用于解决现有的性能问题而不是用来预防，是最后的应对手段）过度使用 will-change 将导致内存使用过多，并导致更复杂的渲染发生，因为浏览器试图为可能的更改做准备。这将导致更差的性能。</li>
<li>减少不必要的视觉变化（频繁的颜色和外观变化）避免频繁的引起页面重绘</li>
</ul>
</li>
<li><p>requestAnimationFrame</p>
<ul>
<li>提供一种方法使得浏览器能在<strong>下一次重绘前调用指定的回调函数</strong>，避免帧丢失。实现更流畅的动画效果</li>
<li>使动画与浏览器刷新率同步，避免不必要的计算和过度绘制，提高性能</li>
<li>标签页切到后台或隐藏时会暂停，从而节省CPU资源</li>
<li>适合连续执行的动画效果</li>
<li>使用cancelAnimationFrame(id)来取消动画帧</li>
<li>与 setTimeout 和 setInterval 相比较更准确<ul>
<li>定时不精确，可能导致帧丢失或卡顿，导致性能问题</li>
</ul>
</li>
<li>可应用到平移、平滑滚动到效果上</li>
</ul>
</li>
<li><p>document.createDocumentFragment()指向 <strong>空DocumentFragment对象</strong> 的引用</p>
<ul>
<li>DocumentFragment是文档片段接口，表示一个没有父对象的最小文档对象</li>
<li>是<strong>DOM空节点</strong>，但不是主DOM树的一部分</li>
<li>存在于内存中不在DOM树中，变化不触发DOM树的重新渲染</li>
<li>当子元素插入到文档片段时不会引起页面回流，因此能带来更好的性能</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<h3 id="在浏览器中输入URL到展示的过程"><a href="#在浏览器中输入URL到展示的过程" class="headerlink" title="在浏览器中输入URL到展示的过程"></a>在浏览器中输入URL到展示的过程</h3></blockquote>
<p>可以大致描述为：<br>输入URL - 发起URL请求（DNS解析、建立TCP连接、发送请求、服务端处理请求并发送响应）- 浏览器接收响应 - 渲染页面</p>
<p><u>这一过程共涉及到3个进程，分别是浏览器进程、网络进程和渲染进程</u></p>
<ol>
<li>处理输入，当在地址栏输入内容时，地址栏先判断是搜索查询还是请求URL，如果是搜索内容，会发送到搜索引擎合成新的带搜索关键字的URL。如果是域名会加上协议（如https）合成完整的url。</li>
<li>点击回车后，浏览器进程通过IPC把URL传给网络进程，网络进程获取到URL先去找缓存中是否有缓存资源，如果有就拦截请求直接返回资源。没有则请求DNS返回域名对应的IP地址和端口号。</li>
<li>建立TCP连接，连接建立后浏览器端构建请求行、请求头、请求正文等数据包，向服务器发送请求</li>
<li>服务端收到请求信息后处理构建响应数据发送回浏览器的网络进程（这一步后断开TCP连接）</li>
<li>网络进程接收到响应数据后进行解析，比如检查状态码、响应处理（重定向在这一步发生，获取URL重新来过）</li>
<li>UI线程通知渲染进程开始渲染页面，渲染过程：<ol>
<li>解析HTML转换为DOM树（就算编写错误也会被HTML规范优雅地处理掉）</li>
<li>加载子资源，包括图像、CSS和JS等外部资源<ul>
<li>script标签会暂停HTML文档的解析，必须加载、解析和执行JS代码后再恢复HTML文档的解析</li>
</ul>
</li>
<li>解析CSS创建CSSOM树（CSS对象模型）并确定每个dom节点的计算样式</li>
<li>主线程遍历DOM树和CSSOM树创建布局树</li>
<li>主线程遍历布局树来创建绘制记录和图层树（绘制记录有点像canvas规定了先画什么）</li>
<li>确定绘制顺序后，开始合成显示在屏幕上<br><img src="/img/RendererProcess.jpeg" alt="图1"></li>
</ol>
</li>
<li>提交导航，更新浏览器界面状态，包括地址栏、浏览器历史记录、网络安全状态等</li>
</ol>
<hr>
<ul>
<li><strong>beforeunload方法</strong><ul>
<li>如果导航是从渲染器进程启动的，比如用户单击链接或JS运行window.location，则渲染器进程首先检查beforeunload处理程序。然后进行与浏览器进程启动导航相同的步骤。</li>
</ul>
</li>
<li>TCP建立连接，<strong>客户端和服务端通过3次握手来确保双方能正确识别对方序列号，从而实现可靠的通信</strong><ul>
<li>客户端发送SYN（同步序列号）包，告诉服务器希望建立连接并指定了一个初始序列号</li>
</ul>
<ul>
<li>服务端确认客户端序列号，发送SYN-ACK包</li>
<li>客户端接收上述包后，发送ACK包确认服务器序列号也发送自己的序列号，表示连接已建立</li>
</ul>
</li>
<li>关闭TCP连接，<strong>通过4次挥手确保连接正常终止，避免数据丢失或不完整的情况</strong><ul>
<li>客户端发送FIN包，表示完成数据发送并不再需要连接（这个包中也包含了一个序列号）</li>
<li>服务端回复ACK包确认收到客户端的FIN包</li>
<li>服务端发送FIN包表示准备好关闭连接了（同样也包含了一个序列号）</li>
<li>客户端回复ACK包确认了服务器序列号，表示接收到关闭连接的请求</li>
</ul>
</li>
<li>如果导航为<strong>重定向跨站点</strong>，则可能不会使用此备用进程，在这种情况下可能需要不同的进程</li>
<li>DNS是域名系统，<strong>互联网中将域名转换为IP地址的分布式数据库系统</strong></li>
</ul>
<blockquote>
<h3 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP / HTTPS"></a>HTTP / HTTPS</h3></blockquote>
<p><strong>HTTP超文本传输协议，HyperText Transfer Protocol</strong><br>是一种用于传输超媒体文档的协议，在客户端和服务器之间作为请求-响应协议工作</p>
<ul>
<li>HTTP不安全，以纯文本传输数据</li>
<li>HTTP/1.0缺陷   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每次请求只能获取一个资源，每个资源都需建立一个新连接</span><br><span class="line">    * 增加了延迟和资源消耗，且无法复用连接</span><br><span class="line">每个请求中头部信息都需重复发送，导致额外的数据传输，增加网络负载</span><br><span class="line">默认不支持长连接</span><br><span class="line">无法有效地管理流量，导致网络阻塞和性能下降</span><br></pre></td></tr></table></figure></li>
<li>HTTP/1.1改进<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">引入长连接（keep-alive），允许客户端和服务端之间的连接在一次请求-响应后保持打开状态</span><br><span class="line">    * 以便后续可以复用连接，减少开销，提高性能</span><br><span class="line">Host头部支持，允许一台服务器承载多个域名对应的网站</span><br><span class="line">缓存控制，如Cache-Control、ETag、Last-Modified等头部字段</span><br><span class="line">分块传输编码，在传输响应时将数据分成多个块进行传输，提高传输效率</span><br><span class="line">支持新的请求方法，如OPTIONS、PATCH、TRACE</span><br></pre></td></tr></table></figure></li>
<li>HTTP/2、HTTP/3<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多路复用，允许多个请求同时在单个连接上进行</span><br><span class="line">二进制传输，更加紧凑、高效，减少数据大小</span><br><span class="line">头部压缩，减少数据大小</span><br><span class="line">服务器推送</span><br><span class="line">优化连接管理，减少开销提高性能</span><br><span class="line">安全性增强</span><br></pre></td></tr></table></figure></li>
<li><em>HTTPS超文本传输安全协议，HyperText Transfer Protocol Secure</em>*</li>
<li>使用SSL/TLS加密数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端向服务端发起HTTPS请求</span><br><span class="line">服务端返回包含数字证书的信息给客户端</span><br><span class="line">客户端检验证书是否合法，生成随机密钥并加密发送给服务端</span><br><span class="line">服务端解密随机密钥</span><br></pre></td></tr></table></figure>
双方使用<strong>随机密钥</strong>来加密和解密通信过程中的数据<br>用于保护网站敏感数据，如用户登录、支付信息等</li>
</ul>
<blockquote>
<h3 id="事件循环机制Event-Loop"><a href="#事件循环机制Event-Loop" class="headerlink" title="事件循环机制Event Loop"></a>事件循环机制Event Loop</h3></blockquote>
<p><strong>用于管理和调度JS代码的执行顺序</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">执行一个宏任务 -&gt; 执行所有微任务 -&gt; 渲染页面 -&gt; 检查是否需要重新渲染 -&gt; 重复执行上述步骤，直到所有队列都为空</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>宏任务 macrotask 也被称为task</strong><ul>
<li>主代码块（用户交互事件：点击、滚动等）</li>
<li>定时器（setTimeout、setInterval）</li>
<li>解析DOM</li>
<li>网络请求</li>
<li>requestAnimationFrame()</li>
<li>UI渲染</li>
</ul>
</li>
<li><strong>微任务 microtask 也被称为jobs</strong><ul>
<li>promise回调函数 .then(..) </li>
<li>catch / finally</li>
<li>Object.observe</li>
</ul>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">new Promise(() =&gt; &#123;&#125;).then()</span><br><span class="line"><span class="bullet">*</span> new Promise(() =&gt; &#123;&#125;) 是一个 构造函数，是 同步任务</span><br><span class="line"><span class="bullet">*</span> 而.then()是 异步微任务</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3></blockquote>
<ul>
<li><strong>XSS攻击，跨站脚本攻击</strong><ul>
<li>目标是向网页中注入恶意脚本代码，从而在用户浏览页面时执行这些恶意代码</li>
<li>通常分为三种：<ol>
<li>存储型XSS攻击，恶意脚本代码存储在网站数据库中，当访问页面时，会从服务端返回并执行</li>
<li>反射型XSS攻击，将恶意链接发送给用户，用户点击后返回恶意代码并执行</li>
<li>DOM型XSS攻击，通过修改网页所使用的DOM环境导致非预期的行为</li>
</ol>
</li>
<li>防御措施：<ul>
<li>cookie设置httpOnly</li>
<li>对用户输入进行严格过滤，转译页面上的输入内容和输出内容</li>
<li>限制JavaScript执行的权限</li>
</ul>
</li>
</ul>
</li>
<li><strong>CSRF(Cross-Site Request Forgery)跨站请求伪造</strong><ul>
<li>在登录过的网站上进行非预期无感知的操作，比如向目标网站发送恶意请求，从而可以发起类似资金转账、更改账号信息等未授权的操作</li>
<li>防止攻击的常见方法：<ol>
<li>使用CSRF Token，随机生成Token，并在服务端检验有效性，确保请求合法</li>
<li>同源检测</li>
<li>使用 SameSite Cookie属性，限制Cookie发送，防止跨站点请求（用于敏感操作的cookie应该具有较短的生命周期）</li>
<li>设置合适的HTTP头部（X-Ruquested-With、Content-Type…）确保请求安全性</li>
<li>使用双重身份验证，增加攻击者难度</li>
<li>设置白名单，不被第三方网站请求；不被第三方网站访问到用户的cookie</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3></blockquote>
<p>一般主流方案：Cookie、Web Storage、IndexedDB、Cache Storage</p>
<hr>
<p><strong>Cookie，通过浏览器在客户端存储少量数据</strong></p>
<ul>
<li>存储量较小，通常为4kb大小；</li>
<li>可以被浏览器设置，每次请求都会自动携带，包含在请求头上，不安全</li>
<li>也可以被服务器设置</li>
<li>使用场景比较有限，通常用于存储用户信息，登录状态等</li>
</ul>
<hr>
<p><strong>Web Storage，在客户端保存键值对数据，限制为4～5MB</strong></p>
<ul>
<li>LocalStorage，在浏览器关闭后仍然保存，直到手动删除。使用方便</li>
<li>SessionStorage，在当前会话结束时即被清除<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要手动获取放到请求中，可以避免CSRF攻击</span><br><span class="line">仅能存储字符串类型的数据，不支持复杂数据类型。</span><br><span class="line">  * 大概是考虑到各种安全问题，还得让各个浏览器统一意见，可能还是为了简化实现</span><br><span class="line">  * 使用 JSON.stringify() 配合 JSON.parse() 解决</span><br><span class="line">    * 无法正确转换JS部分属性，无法转换循环引用的对象</span><br><span class="line">    * undefined, Function, RegExp（转换后变成了空对象）, Date(转换后变成了字符串)</span><br><span class="line">    * Function 比较特殊，可以先调用 .toString() 转换为字符串储存，需要时再 eval 转回来</span><br><span class="line">存储在客户端，存在一定安全风险</span><br><span class="line">不适用大量数据和复杂数据的存储</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>IndexedDB，一种高级的客户端存储技术，允许在浏览器中存储大量结构化数据并支持查询</strong></p>
<ul>
<li>存储容量大，支持事务，可高效地处理大量数据</li>
<li>API相对复杂，不同浏览器兼容性不同</li>
</ul>
<hr>
<p><strong>Cache Storage，浏览器提供的一种缓存机制</strong></p>
<ul>
<li>用于存储<u>请求过的资源</u>，如CSS、JS、图片等</li>
<li>提高页面加载速度，减少网络请求，提升用户体验</li>
</ul>
<blockquote>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3></blockquote>
<p>可以考虑采取以下措施提高性能：</p>
<ul>
<li>使用局部变量来提高访问速度</li>
<li>避免使用eval函数，因为它会影响性能</li>
<li>使用事件委托来减少事件处理程序的数量</li>
<li>减少DOM操作次数，避免频繁的重绘和重排；可使用批量更新</li>
<li>使用合适的数据结构和算法</li>
<li>使用异步加载来延迟不必要的资源加载</li>
<li>缓存重复的计算结果</li>
<li>使用Web Workers进行多线程处理，提高性能</li>
</ul>
<blockquote>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3></blockquote>
<p>是浏览器基于同源策略的一种安全手段，是对安全性做的限制</p>
<p><u>同源策略：是一种约定，用于隔离潜在恶意文件的安全机制，通常不允许不同源之间的读操作</u></p>
<p><strong>同源三要素：协议protocol / 主机host / 端口port 相同</strong><br><strong>非同源的请求就会产生跨域</strong></p>
<p>常见于以下场景：</p>
<ul>
<li>ajax跨域请求</li>
<li>跨文档消息通信，一个页面通过postMessage发送消息到另一个页面时，如果两个页面的域名不同，则会触发跨域问题</li>
<li>嵌套的跨域资源，如iframe、img、script<br>解决方案：</li>
</ul>
<ol>
<li>JSONP（JSON with Padding）动态创建script标签来加载脚本，实现跨域数据传递<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">url, callback, success</span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">     script.<span class="property">url</span> = url;</span><br><span class="line">     script.<span class="property">async</span> = <span class="literal">true</span>;</span><br><span class="line">     script.<span class="property">type</span> = <span class="string">&#x27;text/javascript&#x27;</span>;</span><br><span class="line">     <span class="variable language_">window</span>[callback] = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">         success &amp;&amp; <span class="title function_">success</span>(data);</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可兼容老式浏览器</li>
<li>需要服务端支持且只支持GET请求</li>
</ul>
</li>
<li>CORS（Cross-Origin Resource Sharing）跨境资源共享。服务端设置响应头Access-Control-Allow-Origin: * | <code>&lt;origin&gt;</code>，允许指定的域名访问资源<ul>
<li>支持所有请求方法，但兼容性比JSONP差</li>
<li>实现关键在服务端</li>
</ul>
</li>
<li>代理服务器，在服务端设置代理服务器，由代理服务器转发请求，实现跨域访问。（node中间件）</li>
<li>反向代理，将需要访问的资源部署在同一域名下，通过反向代理将请求转发到真实的资源地址。（Nginx）<ul>
<li>node中间件和Nginx反向代理都利用了<strong>服务器对服务器无同源策略</strong></li>
</ul>
</li>
<li>iframe嵌套通信，document.domain + iframe / window.name + iframe / location.hash + iframe</li>
<li>基于OPTIONS方法进行过滤，发送一个预检请求到服务器，是否允许其实际请求</li>
<li>postMessage，是HTML5 XMLHttpRequest Level 2中的API，可以实现跨文档通信</li>
<li>webSocket，是HTML5的一个持久化协议，不受同源策略限制，可以建立跨域连接，可与postMessage配合使用。是一个长连接long poll</li>
</ol>
<p>代理服务器 与 反向代理服务器 区别：</p>
<ol>
<li>代理服务器位于客户端和原始服务端间，而反向代理服务器位于客户端和多个原始服务器间</li>
<li>代理服务器主要用于隐藏客户端的真实IP地址、提高访问速度、过滤内容等</li>
<li>反向代理服务器主要用于负载均衡、安全性、隐藏服务器架构等方面</li>
<li>代理服务器的配置由客户端控制，需手动配置代理服务器的地址和端口</li>
<li>反向代理服务器的配置由服务端控制，客户端无需感知反向代理服务器的存在</li>
</ol>
<p>实际应用中，反向代理服务器更为常见。<br>特别是在构建高可用性、高性能的Web应用时<br>通过反向代理，可以将请求分发给不同的服务器，实现负载均衡和故障转移；<br>同时，反向代理也可以用于缓存静态内容，提高访问速度；<br>此外，反向代理还可以作为防火墙，过滤恶意请求，增强系统的安全性。</p>
<blockquote>
<h3 id="Node的Event-Loop事件循环"><a href="#Node的Event-Loop事件循环" class="headerlink" title="Node的Event Loop事件循环"></a>Node的Event Loop事件循环</h3><p><strong>Timers -&gt; Pending callbacks -&gt; Idle/Prepare -&gt; IO Poll -&gt; Check -&gt; Closing callbacks</strong></p>
</blockquote>
<ul>
<li><p>Timers 用于存储定时器的回调函数(setInterval、setTimeout)</p>
</li>
<li><p>Pending callbacks 执行与操作系统相关的回调函数，比如启动服务器端应用监听端口操作</p>
</li>
<li><p>Idle/Prepare 系统内部使用，可以不关注</p>
</li>
<li><p>IO Poll 存储I/O操作的回调函数队列，例如文件读写操作</p>
<ul>
<li>如果事件队列中无回调函数，但 Check阶段 或 Timers队列 中有需执行的回调函数<ul>
<li>那么事件循环会移至 Check阶段 或 Closing callbacks 并从 Timers 进入下一次循环</li>
<li>否则会在IO Poll阶段停留一段时间以等待新的回调函数进入    </li>
</ul>
</li>
</ul>
</li>
<li><p>Check 存储setImmediate API 的回调函数</p>
</li>
<li><p>Closing callbacks 执行与关闭事件相关回调函数，比如关闭数据库连接</p>
</li>
<li><p>Node适合<u>I/O密集型任务，不适合CPU密集型任务</u>，因为主线程一旦阻塞，就会卡程序</p>
</li>
<li><p>宏任务：setInterval、setTimeout、I/O、setImmediate</p>
</li>
<li><p>微任务：Promise.than/catch/finally、process.nextTick</p>
</li>
<li><p>宏任务微任务各自的回调函数放在各自的任务队列中</p>
</li>
<li><p><strong>微任务优先级高于宏任务</strong></p>
</li>
<li><p><strong>微任务中的nextTick高于其他微任务，先进先出</strong></p>
</li>
</ul>
<blockquote>
<h3 id="数据脱敏，用于保护敏感数据的隐私和安全性"><a href="#数据脱敏，用于保护敏感数据的隐私和安全性" class="headerlink" title="数据脱敏，用于保护敏感数据的隐私和安全性"></a>数据脱敏，用于保护敏感数据的隐私和安全性</h3></blockquote>
<ul>
<li>通常用于 非生产环境测试、合规性要求、数据共享</li>
<li>方法包括 替换敏感数据、部分隐藏、加密、数据掩护、数据删除</li>
</ul>
<blockquote>
<h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><p><strong>get / post / options / put / patch / delete / head / trace</strong></p>
</blockquote>
<ul>
<li>get，用于向服务器请求获取数据，如获取网页、图片等<ul>
<li>请求参数附在URL上，以查询字符串形式发送</li>
<li>请求长度受限，不修改资源，无副作用</li>
<li>可被缓存，也可以被书签、历史记录保存</li>
<li>数据在URL中可见，<u>不适合发送敏感信息</u></li>
</ul>
</li>
<li>post，用于向服务器提交数据，如表单数据、上传文件等操作；更多编码格式<ul>
<li>请求参数附在请求体中，不会在浏览器历史记录中显示</li>
<li>不可被浏览器缓存，不会被书签、历史记录保存</li>
<li>数据不暴露在URL中，适合发送大量数据和敏感信息</li>
</ul>
</li>
<li>head，类似于get，但服务器只返回请求头部信息，通常用于检查资源的元数据，例如文件是否存在、最后修改时间</li>
<li>options，用于请求服务器告知客户端对指定资源支持的各种请求方法、HTTP头部信息等</li>
<li>put，用于向服务器发送数据，从而更新指定资源内容。如果资源不存在，则创建一个新资源</li>
<li>patch，类似于put，但仅传输需要更新的数据部分，非整个资源</li>
<li>delete，用于请求服务器删除指定的资源</li>
<li>trace，用于在请求链路中追踪请求的传输路径，常用于诊断和调试</li>
</ul>
<blockquote>
<h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3></blockquote>
<ul>
<li>200: 成功，并返回数据</li>
<li>301: 永久移动，永久重定向，浏览器会缓存</li>
<li>302: 临时重定向</li>
<li>304: 资源未修改，可使用缓存</li>
<li>400: 请求语法错误</li>
<li>404: 资源不存在</li>
<li>403: 拒绝请求</li>
<li>500: 服务器错误</li>
<li>…</li>
</ul>
<blockquote>
<h3 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h3></blockquote>
<ul>
<li>进程是CPU资源分配的最小单位，是应用程序运行时的实例对象；进程间相互独立不受干扰；可以通过IPC来实现通信</li>
<li>线程是CPU调度的最小单位，被包裹在进程中，应用程序具体要做的每件事情生成了一个个线程，类似于一个待办列表</li>
<li>线程上下文切换比进程上下文切换要快得多</li>
<li>CPU可以有很多进程，但资源是固定的。进程越多，CPU分出去的资源越多就越卡。</li>
</ul>
<blockquote>
<h3 id="JS为什么是单线程"><a href="#JS为什么是单线程" class="headerlink" title="JS为什么是单线程"></a>JS为什么是单线程</h3></blockquote>
<p>这是由起初设计的用途和运行环境所决定</p>
<ul>
<li>起初被设计用于web页面互动及操作DOM，如果是多线程，会带来复杂的并发问题，如死锁（两个线程相互依赖）、同步问题、竞态条件（多个线程访问共享资源引起的不确定性和不可预测的行为）等</li>
<li>多个js脚本同时修改页面可能会引起页面冲突，单线程保证了脚本顺序执行</li>
<li>在每个页面中多线程可能会导致页面响应变慢或崩溃</li>
<li>可以通过事件循环机制，处理异步任务，如网络请求、定时器等</li>
</ul>
<blockquote>
<h3 id="web-worker，是HTML5提供的JS线程"><a href="#web-worker，是HTML5提供的JS线程" class="headerlink" title="web worker，是HTML5提供的JS线程"></a>web worker，是HTML5提供的JS线程</h3></blockquote>
<ol>
<li>独立线程，与主线程相互独立，不阻塞主线程。可并行执行多个任务</li>
<li>无法访问和操作DOM元素</li>
<li>支持多线程通信</li>
<li>受同源限制，无法加载本地资源<br>使用场景：需要大量计算、网络请求等耗时的任务</li>
</ol>
<blockquote>
<h3 id="跨标签页通讯"><a href="#跨标签页通讯" class="headerlink" title="跨标签页通讯"></a>跨标签页通讯</h3></blockquote>
<ol>
<li>设置同域下共享的 LocalStorage 或 SessionStorage，适用于较小量的数据通讯</li>
<li>Cookies，在相同域名下的不同路径间共享数据</li>
<li>window.opener，如果通过window.open()打开的新标签页，可以通过该属性获取父窗口，并在父子窗口间通讯</li>
<li>postMessage</li>
<li>借助服务端或中间层实现</li>
<li>SharedWorker，特殊的Web Worker，可以被多个标签页共享</li>
</ol>
<blockquote>
<h3 id="事件冒泡、事件捕获、事件委托"><a href="#事件冒泡、事件捕获、事件委托" class="headerlink" title="事件冒泡、事件捕获、事件委托"></a>事件冒泡、事件捕获、事件委托</h3></blockquote>
<ul>
<li>事件冒泡，当一个事件在DOM元素上触发时，它会首先在事件的目标元素上触发，然后逐级向上传播到文档的根元素。这个过程就像泡泡一样从底部浮到顶部<ul>
<li>可调用event.stopPropagation() 来阻止事件继续冒泡</li>
</ul>
</li>
<li>事件捕获与冒泡相反，从文档根元素开始，向下传播到目标元素<ul>
<li>可调用event.stopPropagation() 来阻止事件继续向下传播到目标元素</li>
</ul>
</li>
<li>事件委托对大量相似的元素，将事件处理程序添加到这一组元素的共同祖先上<ul>
<li>利用 事件冒泡 来处理事件，通过检测event.target属性确定事件的真正目标</li>
<li>减少事件处理器的数量，提高性能（在处理大量相似元素上）</li>
<li>对于动态添加的元素也可以触发事件，无需额外绑定</li>
<li>简化代码，易于管理</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="setTimeout-0-会立即输出吗"><a href="#setTimeout-0-会立即输出吗" class="headerlink" title="setTimeout(0) 会立即输出吗"></a>setTimeout(0) 会立即输出吗</h3></blockquote>
<ul>
<li>不会立即执行，而是等待当前执行栈中所有任务执行完才会执行，取决于JS的事件循环机制</li>
<li>看当时执行的机器状态，可能会先输出也可能后输出</li>
</ul>
<blockquote>
<h3 id="超时调用setTimeout-间歇调用setInterval"><a href="#超时调用setTimeout-间歇调用setInterval" class="headerlink" title="超时调用setTimeout() 间歇调用setInterval()"></a>超时调用setTimeout() 间歇调用setInterval()</h3></blockquote>
<ul>
<li>返回一个数值ID作为唯一标识符，可用来取消<ul>
<li>clearTimeout() clearInterval()</li>
<li>clearInterval() 更需要被取消，不加干涉时，setInterval会一直执行</li>
<li>一般建议使用setTimeout来模拟setInterval，因为后一个setInterval可能在前一个setInterval结束前就启动了</li>
</ul>
</li>
</ul>
<blockquote>
<p>幂等</p>
</blockquote>
<ul>
<li>一次请求和多次请求，对资源产生的影响是一样的。</li>
<li>GET、PUT、DELETE</li>
<li>防止按钮重复点击提交（多次提交应该只处理一次）；扣款</li>
<li>重复请求接口时，要确保结果不因为多次请求而出问题</li>
<li>接口设计时，区分是否要保证接口幂等，比如上传、更新信息</li>
</ul>

  </div>
</article>

        
        
      </div>
      <footer class="footer">
    <div class="footer-content">
        <p>&copy; 2025 蘑菇小记</p>
        <p class="copyright">All rights reserved.</p>
    </div>
</footer>
    </div>
    <button id="back-to-top" title="回到顶部">↑</button>
  </body>
</html>

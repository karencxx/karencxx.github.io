<!DOCTYPE html>
<html lang="">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSSNote | 蘑菇小记</title>
    <link rel="stylesheet" href="/css/breeze.css">
    <script src="/js/toc.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const backToTopButton = document.getElementById('back-to-top');

            // 当页面滚动超过 300px 时显示按钮
            window.onscroll = function() {
                if (document.body.scrollTop > 300 || document.documentElement.scrollTop > 300) {
                backToTopButton.style.display = "block";
                } else {
                backToTopButton.style.display = "none";
                }
            };
            
            // 点击按钮时平滑滚动回顶部
            backToTopButton.addEventListener('click', function() {
                const scrollToTop = function() {
                    const c = document.documentElement.scrollTop || document.body.scrollTop;
                    if (c > 0) {
                    window.requestAnimationFrame(scrollToTop);
                    window.scrollTo(0, c - c / 8);
                    }
                };
                scrollToTop();
            });
        });
        window.isMobile = /mobile|android|iphone|ipad|phone/i.test(navigator.userAgent);
    </script>

    
<meta name="generator" content="Hexo 5.4.2"></head>
    
  <body>
    <div class="container">
      <header class="header-container post-header">
    <div class="title">
        <img src="/images/Icon-leaf.png" class="leaf-icon">
        <a href="/">蘑菇小记</a>
    </div>
    <nav class="nav">
        <ul>
            
                <li><a href="/archives" class="nav-item">Archives</a></li>
            
                <li><a href="/about" class="nav-item">About</a></li>
            
          </ul>
    </nav>
</header>

      <div class="main-content">
        
          

<aside class="post-toc">
    <div class="toc-wrapper collapsed">
  <div class="toc-toggle">
    <span class="toc-toggle-icon"></span>
  </div>
  <div class="toc-content">
    
      <div class="toc-body">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS"><span class="toc-text">CSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">盒模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFC-block-formatting-context-%EF%BC%8C%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">BFC (block formatting context)，块级格式化上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E5%88%97%E6%96%B9%E5%BC%8F%E4%BC%9A%E5%88%9B%E5%BB%BABFC%E6%88%96%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-text">下列方式会创建BFC或触发条件:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8"><span class="toc-text">BFC有哪些作用:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">层叠上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E8%B6%B3%E4%BB%A5%E4%B8%8B%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%83%E7%B4%A0%E5%B0%B1%E4%BC%9A%E5%BD%A2%E6%88%90%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">满足以下任意一个条件的元素就会形成层叠上下文:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80"><span class="toc-text">居中布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#positon-%E8%AF%A5%E5%B1%9E%E6%80%A7%E7%94%A8%E4%BA%8E%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%9C%A8%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">positon 该属性用于指定一个元素在文档中的定位方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%BA%E5%88%B6"><span class="toc-text">css样式优先级机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#css%E7%BB%A7%E6%89%BF"><span class="toc-text">css继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%8C%E7%94%A8%E6%9D%A5%E9%80%89%E6%8B%A9%E7%89%B9%E5%AE%9A%E5%85%83%E7%B4%A0%E4%BB%A5%E5%BA%94%E7%94%A8%E6%A0%B7%E5%BC%8F%E7%9A%84%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-text">css选择器，用来选择特定元素以应用样式的的模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%BB%E9%99%A4%E6%B5%AE%E5%8A%A8%EF%BC%8C%E9%98%B2%E6%AD%A2%E7%88%B6%E7%BA%A7%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7"><span class="toc-text">去除浮动，防止父级高度塌陷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#margin-%E5%A1%8C%E9%99%B7%E7%8E%B0%E8%B1%A1"><span class="toc-text">margin 塌陷现象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#link%E4%B8%8E-import%E5%8C%BA%E5%88%AB"><span class="toc-text">link与@import区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-text">CSS伪类和伪元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB"><span class="toc-text">伪类 :</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-text">伪元素 ::</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS3%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">CSS3新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%8A%A8%E7%94%BB"><span class="toc-text">CSS动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transition%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB"><span class="toc-text">transition过渡动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#animation-keyframes"><span class="toc-text">animation &#x2F; keyframes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%8B%A5%E6%9C%89%E8%BE%83%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD%E8%A1%A8%E7%8E%B0"><span class="toc-text">动画属性，拥有较好的性能表现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%9F%9F%E5%A4%84%E7%90%86%E5%99%A8-Sass-Less-Postcss-Stylus"><span class="toc-text">CSS域处理器 Sass &#x2F; Less &#x2F; Postcss &#x2F; Stylus</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8%EF%BC%88Cascading-Style-Sheets%EF%BC%89"><span class="toc-text">CSS层叠样式表（Cascading Style Sheets）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E7%9A%84CSS%E4%BB%A3%E7%A0%81"><span class="toc-text">实现浏览器兼容性的CSS代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%E8%AE%BE%E8%AE%A1"><span class="toc-text">响应式设计和自适应设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BEM%EF%BC%88Block-Element-Modifier%EF%BC%89"><span class="toc-text">BEM（Block Element Modifier）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">零散知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li></ol>
      </div>
    
  </div>
</div>


</aside>

<article class="post-detail has-toc toc-collapsed">
    <div class="post-title-container">
        <h1 class="post-title">CSSNote</h1>
    </div>
    <div class="post-meta">
        <time datetime="2024-04-08T06:50:24.000Z">2024-04-08</time>
        
          <div class="post-tags">
            
              <a href="/tags/%E5%A4%8D%E4%B9%A0/" class="post-tag">复习</a>
            
          </div>
        
        
          <div class="post-categories">
            
              <a href="/categories/CSS/" class="post-category">CSS</a>
            
          </div>
        
  </div>
  <div class="post-content">
    

    <blockquote>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2></blockquote>
<ul>
<li>是一种用于描述文档样式和外观的语言</li>
<li>控制着网页的布局、颜色、字体等方面的样式</li>
<li>三种引入方式：内联样式 / 嵌入样式 / 外部样式表<ul>
<li>区别在于样式的定义位置和复用性</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2></blockquote>
<p>页面渲染时dom元素所采用的<strong>布局模型</strong>，是CSS布局的基础。<br>它规定了元素如何计算其大小和位置，它将所有元素表示为一个个矩形盒子。<br>每个盒子由四部分组成: </p>
<ul>
<li>内容区域content area / 内边距区域padding area / 边框区域border area / 外边距区域margin area<br>可通过<u>box-sizing</u>设置，根据计算页面宽高的区域可分为：<ul>
<li>content-box (w3c 标准盒模型)</li>
<li>border-box (IE 盒模型)</li>
<li>padding-box</li>
<li>margin-box </li>
</ul>
</li>
</ul>
<p><u>默认为content-box，即w3c标准盒模型</u></p>
<p>box-sizing属性用于更改默认的CSS盒模型计算方式</p>
<p>每个盒子有四个边界：</p>
<ul>
<li>内容边界Content edge / 内边距边界 Padding Edge / 边框边界 Border Edge / 外边框边界 Margin Edge</li>
</ul>
<blockquote>
<p>IE盒模型缺陷，指早期版本的IE调整网页元素大小的方法和W3C推荐的标准方式不同。在IE6中浏览器支持了一种解决这种差异的可选渲染模式（遵从标准模式）</p>
</blockquote>
<p><img src="/img/box_model.png" alt="图1"></p>
<blockquote>
<h2 id="BFC-block-formatting-context-，块级格式化上下文"><a href="#BFC-block-formatting-context-，块级格式化上下文" class="headerlink" title="BFC (block formatting context)，块级格式化上下文"></a>BFC (block formatting context)，块级格式化上下文</h2></blockquote>
<ul>
<li>web页面可视css渲染的一部分（css布局的一个概念）</li>
<li>块级盒子布局过程发生的区域</li>
<li>浮动元素与其他元素交互的区域</li>
</ul>
<hr>
<h3 id="下列方式会创建BFC或触发条件"><a href="#下列方式会创建BFC或触发条件" class="headerlink" title="下列方式会创建BFC或触发条件:"></a>下列方式会创建BFC或触发条件:</h3><ul>
<li>html根元素</li>
<li>浮动元素, 即float不为none的元素</li>
<li>绝对定位元素, position: absolute / fixed</li>
<li>行内块元素, display: inline-block</li>
<li>表格单元格, display: table-cell</li>
<li>表格标题, display: table-caption</li>
<li>display: flow-root的元素</li>
<li>contain值为layout / content / paint</li>
<li>overflow不为visible / clip的块元素</li>
<li>弹性元素, display: flex / inline-flex的直接子元素</li>
<li>网格元素, display: grid / inline-grid的直接子元素</li>
<li>匿名表格单元格元素, display: table / table-row / table-row-group / table-header-group / table-footer-group / inline-table</li>
<li>多列容器, 元素的column-count或column-width不为auto, 包括column-count: 1</li>
<li>column-span为all的元素始终会创建一个新的BFC, 即使该元素没有包裹在一个多列容器中</li>
</ul>
<hr>
<h3 id="BFC有哪些作用"><a href="#BFC有哪些作用" class="headerlink" title="BFC有哪些作用:"></a>BFC有哪些作用:</h3><ul>
<li>自适应两栏布局 (display: flow-root)</li>
<li>可以阻止元素被浮动元素覆盖(清除外部浮动)</li>
<li>包含浮动元素–清除内部浮动（两个div都位于同一个BFC之中）</li>
<li>可以阻止margin重叠（当分属于不同BFC时）</li>
</ul>
<p><u>BFC对浮动定位与清除浮动都很重要。</u><br>来自：两个块元素外边距合并问题</p>
<blockquote>
<h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2></blockquote>
<p><u>HTML元素沿着面向用户的一条虚构的z轴顺序排开，是对HTML元素的一个三维构想</u><br>运用z-index，将元素提升为一个比较特殊的图层，在三维空间(z轴)中高出普通元素一等</p>
<ul>
<li>z-index属性设置元素的堆叠顺序</li>
<li>拥有更高堆叠顺序的元素总是会处于顺序较低的元素的前面</li>
<li>z-index仅能在定位元素上奏效（position属性值不为static以外的元素，包括<strong>relative，absolute，fixed</strong>样式） </li>
</ul>
<hr>
<h3 id="满足以下任意一个条件的元素就会形成层叠上下文"><a href="#满足以下任意一个条件的元素就会形成层叠上下文" class="headerlink" title="满足以下任意一个条件的元素就会形成层叠上下文:"></a>满足以下任意一个条件的元素就会形成层叠上下文:</h3><ul>
<li>html根元素</li>
<li>position为absolute / relative且z-index不为auto</li>
<li>position为fixed / sticky</li>
<li>网格布局grid或弹性布局flex容器里的子元素且z-index不为auto</li>
<li>opacity属性值小于1的元素</li>
<li>…</li>
</ul>
<hr>
<ul>
<li>层叠上下文可以包含在其他层叠上下文中，并且一起创建一个层叠上下文的层级</li>
<li>每个层叠上下文都完全独立于它的兄弟元素（当处理层叠时只考虑子元素）</li>
<li>每个层叠上下文都是自包含的（当一个元素的内容发生层叠后，该元素将被作为整体在父级层叠上下文中按顺序进行层叠）</li>
</ul>
<blockquote>
<h2 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h2></blockquote>
<ul>
<li>水平居中<ul>
<li>行内元素：text-align: center;</li>
<li>块级元素： margin: 0 auto; </li>
<li>absolute + transform</li>
<li>flex + justify-content</li>
</ul>
</li>
<li>垂直居中<ul>
<li>上级高度可知时：line-height: height</li>
<li>absolute + transform</li>
<li>flex + align-items </li>
<li>table布局</li>
</ul>
</li>
<li>水平垂直居中<ul>
<li>absolute + transform</li>
<li>display: flex + justify-content + align-items </li>
<li>display: grid + justify-content + align-items</li>
<li>display: table-cell + text-align + vertical-align</li>
</ul>
</li>
</ul>
<h3 id="positon-该属性用于指定一个元素在文档中的定位方式"><a href="#positon-该属性用于指定一个元素在文档中的定位方式" class="headerlink" title="positon 该属性用于指定一个元素在文档中的定位方式"></a>positon 该属性用于指定一个元素在文档中的定位方式</h3><ul>
<li>static：正常布局，即元素在文档常规流中当前的布局位置。top、left、right、bottom、z-index无效，按正常文档流进行排列</li>
<li>relative：元素<u>不脱离文档流</u>，在原始位置上不改变页面布局的前提下调整元素位置，不影响其他元素偏移。未添加定位时的位置会多出一块空白</li>
<li>sticky：元素根据正常文档流进行定位，然后相对他的最近的滚动祖先和块级祖先进行偏移，偏移值不影响任何其他元素位置</li>
<li>absolute：元素<u>会被移出正常文档流，不预留空间</u>，可设置外边距，不与其他边距合并</li>
<li>fixed：元素<u>会被移出正常文档流，不预留空间</u>，通过指定元素相对于屏幕视口的位置来指定元素位置，位置随屏幕滚动时不会改动，所固定参照对象是可视窗口</li>
</ul>
<ul>
<li>absolute的containing block计算方式跟正常流有什么不同？<ul>
<li>正常流中，元素的containing block是其最近的块级祖先元素</li>
<li>但绝对定位absolute可能会是以下几种：<ul>
<li>position: relative / absolute的祖先元素</li>
<li>离它最近的包含块containing block，即最近的块级祖先元素</li>
<li>initial containing block，即viewport（如果都没找到符合的祖先元素）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><u>viewport是指浏览器中用来显示网页内容的区域，即用户能看到的可视区域。随浏览器窗口大小或缩放操作而改变</u></p>
<p>可以通过下面的单位或属性来控制网页内容在视口中的呈现方式</p>
<ul>
<li>viewport单位: vw / vh</li>
<li>viewport相关的meta标签: width / initial-scale / minimum-scale / maxinum-scale</li>
<li>css视口单位: vmin / vmax</li>
</ul>
<blockquote>
<h2 id="css样式优先级机制"><a href="#css样式优先级机制" class="headerlink" title="css样式优先级机制"></a>css样式优先级机制</h2></blockquote>
<ul>
<li>确定样式应用优先级的规则 </li>
</ul>
<p>!important &gt; 行内样式 &gt; id选择器 &gt; 类选择器 &gt; 标签｜伪类｜属性选择器 &gt; 伪元素 &gt; 继承 &gt; 通配符* &gt; 默认</p>
<ul>
<li>从右往左解析</li>
</ul>
<h3 id="css继承"><a href="#css继承" class="headerlink" title="css继承"></a>css继承</h3><p>-指某些属性值可以从父元素传递给子元素。</p>
<p><u>css可继承的属性: </u>字体属性 &amp; 文本属性 &amp; 列表属性 &amp; 表格布局属性 &amp; 元素可见性<br>| 字体系列属性 | font-size / font-weight … |<br>| 文本系列属性 | color / line-height … |<br>| 元素可见性 | visibility |<br>| 表格布局属性 | empty-cells / border-collapse … |<br>| 列表属性 | list-style … |<br>| 光标属性 | cursor |</p>
<blockquote>
<p>font-size继承的是<strong>基于父元素计算后的值</strong></p>
</blockquote>
<p><u>不可继承的属性: </u>盒子模型属性 &amp; 定位属性 &amp; 文本属性 &amp; 显示属性<br>| 显示属性 | display |<br>| 文本属性 | vertical-align / text-decoration |<br>| 盒子模型属性 | width / height / padding / margin / border |<br>| 定位属性 | position / float |<br>| 内容属性 | content |<br>| 页面样式属性 | size … |<br>| 轮廓样式属性 | outline / outline-style … |</p>
<p>继承关键字：</p>
<ul>
<li>inhreit: 从父元素继承它的值。如果父元素没有明确定义，则搜DOM树直到找到，无法找到时会使用浏览器默认值</li>
<li>initial: css3新关键字，浏览器默认设置的css属性值</li>
<li>unset: 如果该属性是默认继承属性，则该值等同于inherit，如果该属性是非继承属性，则等同于initial</li>
<li>all: 是一个属性而非一个值，例如重置所有css属性为浏览器默认：{ all: initial }</li>
</ul>
<blockquote>
<h2 id="css选择器，用来选择特定元素以应用样式的的模式"><a href="#css选择器，用来选择特定元素以应用样式的的模式" class="headerlink" title="css选择器，用来选择特定元素以应用样式的的模式"></a>css选择器，用来选择特定元素以应用样式的的模式</h2></blockquote>
<p>CSS选择器优先级是确定哪个CSS规则应用于元素的机制。当多个规则匹配到一个元素时，CSS选择器优先决定哪个规则最终生效。<br>优先级高的会覆盖优先级低低。</p>
<p>ID选择器、类选择器、标签选择器、属性选择器、关系选择器(+ &gt; ~  ‘‘ ||)、通配符选择器、伪类选择器</p>
<p><u>关系选择器(+ &gt; ~  ‘‘ ||)</u></p>
<ul>
<li>div &gt; p div的直接子节点p</li>
<li>div + p 与div相邻的节点p</li>
<li>div ~ p div后的任何节点p</li>
</ul>
<blockquote>
<h2 id="去除浮动，防止父级高度塌陷"><a href="#去除浮动，防止父级高度塌陷" class="headerlink" title="去除浮动，防止父级高度塌陷"></a>去除浮动，防止父级高度塌陷</h2></blockquote>
<p><u>为什么会产生浮动</u><br>起初为了实现文字环绕图片这种类似于word上的效果。运用float定义元素在方向上的浮动，改变元素在页面上的位置。（是css2增加的属性）<br>但加上float属性后，元素被移出正常文档流，然后向左或向右平移直到碰到容器的边框或另一个浮动元素为止。<br><u>带来的问题</u></p>
<ul>
<li>破坏父级高度，造成高度塌陷</li>
<li>影响了与父级同级的元素</li>
<li>与浮动元素同级的非浮动内联元素也会跟随其后，影响布局</li>
</ul>
<p><u>如何清除</u></p>
<ul>
<li>父级设置高度</li>
<li>增加尾部元素清除浮动<ul>
<li>添加一个空的div，设置样式clear:both<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>clearfix方法，即为父元素添加一个不浮动的::after伪元素<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&amp;<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line">// 兼容写法</span><br><span class="line">&amp;<span class="selector-pseudo">::after</span> &#123; </span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">clear</span>: both;　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>溢出隐藏：父级元素设置 overflow: hidden / auto</li>
<li>创建父级BFC</li>
</ul>
<blockquote>
<p>clear属性指定一个元素是否必须移动(清除浮动后)到位于它之前的浮动元素的下面，适用于浮动和非浮动元素</p>
</blockquote>
<p><img src="/img/css-float.png" alt="图2"></p>
<p><u>position、display、overflow、float这些特性相互叠加时</u></p>
<ul>
<li>display规定元素生成外框的类型;</li>
<li>position规定元素的定位类型;</li>
<li>float是布局方式，定义元素在方向上的浮动;</li>
<li><strong>position: absolute/fixed 优先级最高</strong><ul>
<li>当他们出现时float不起作用，display值需要重新计算</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="margin-塌陷现象"><a href="#margin-塌陷现象" class="headerlink" title="margin 塌陷现象"></a>margin 塌陷现象</h2></blockquote>
<p>当垂直方向上相邻的两个块级元素出现时，它们之间的垂直外边距会重合<br><u>产生所谓的塌陷现象，会导致元素之间的间距比预期要小或完全没有</u><br><u>取两者margin间较大的值展示</u>  </p>
<p>通常发生在：</p>
<ul>
<li>相邻兄弟元素的margin塌陷</li>
<li>父元素和第一个或最后一个子元素margin塌陷</li>
</ul>
<p>解决方法：</p>
<ul>
<li>只给一个元素设置间距</li>
<li>创建一个新的BFC（给div包裹一个外层div）防止外边距重叠</li>
<li>父子元素间可设置border或padding避免相遇</li>
</ul>
<blockquote>
<h2 id="link与-import区别"><a href="#link与-import区别" class="headerlink" title="link与@import区别"></a>link与@import区别</h2></blockquote>
<ul>
<li>link功能较多，可以定义RSS，定义Rel等作用，而@import只能用于加载css</li>
<li>当解析到link时，页面会同步加载所引的css，而@import所引用的css会等到页面加载完才被加载</li>
<li>@import需要 IE5 以上才能使用</li>
<li>link可以使用js动态引入，@import不行</li>
</ul>
<blockquote>
<h2 id="CSS伪类和伪元素"><a href="#CSS伪类和伪元素" class="headerlink" title="CSS伪类和伪元素"></a>CSS伪类和伪元素</h2></blockquote>
<ul>
<li><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类 :"></a>伪类 :</h3><ul>
<li>添加在一个具体的已存在的元素上，用来指定所选元素的特殊状态，类似于给元素加了一个class类，但实际不会存在</li>
<li>:root 匹配文档树的根元素，对于文档树来说,:root 表示 <html> 元素，除了优先级更高之外，与html选择器相同。</li>
<li>:visited / :hover / :active / :checked / :first-child / :paused / :playing …</li>
</ul>
</li>
<li><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素 ::"></a>伪元素 ::</h3><ul>
<li>在DOM里新生成了个虚拟元素，选中的是新标签，类似于标签选择器</li>
<li>::after / ::before<br><u>当用一个dom元素无法绘制图案时，同时为了保持dom结构的语义化清晰，不希望改变其结构，就可以用伪元素</u></li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h2></blockquote>
<ul>
<li><p>flexbox弹性盒子布局</p>
</li>
<li><p>grid网格布局</p>
</li>
<li><p>响应式设计支持</p>
<ul>
<li>媒体查询、弹性单位和网格布局等特性</li>
</ul>
</li>
<li><p>过渡transition和动画animation，无需使用javascript</p>
</li>
<li><p>变形transform</p>
</li>
<li><p>边框和背景效果（圆角边框、阴影边框等）（渐变背景、背景图像尺寸调整等）</p>
</li>
<li><p>字体和文字效果，支持使用@font-face规则引入自定义字体，文字效果有文字阴影、文字渐变等</p>
</li>
<li><p>多列布局</p>
</li>
<li><p>自定义样式，实现样式模块化和复用</p>
</li>
<li><p>新增伪类<br>  ｜ :first-of-type ｜一组兄弟元素中<u>该类型集合的首个元素</u> ｜ <br>  ｜ :last-of-type ｜ 一组兄弟元素中<u>该类型集合的最后元素</u> ｜     <br>  ｜ :only-of-type ｜ 唯一一个没有相同类型的兄弟元素，可以是任意类型 ｜<br>  ｜ :only-child  ｜ 没有任何兄弟的唯一子元素 ｜<br>  ｜ :nth-child(2|2n|2n+1) ｜ 匹配条件的元素集合 ｜<br>  ｜ :enabled / :disabled / :checked  ｜ 表单组件状态 / 单选框或复选框选中状态 ｜</p>
</li>
</ul>
<blockquote>
<h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2></blockquote>
<ul>
<li><h3 id="transition过渡动画"><a href="#transition过渡动画" class="headerlink" title="transition过渡动画"></a>transition过渡动画</h3>参数：property name | duration | timing function | delay<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition</span>: margin-right <span class="number">4s</span> ease-in-out <span class="number">1s</span>;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="animation-keyframes"><a href="#animation-keyframes" class="headerlink" title="animation / keyframes"></a>animation / keyframes</h3>参数： name @keyframes  | duration | timing function | delay | times | direction | fill-mode | play-sate |<br>@keyframes规则定义动画关键帧，用animation属性将动画应用于元素<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation</span>: <span class="number">3s</span> ease-in <span class="number">1s</span> <span class="number">2</span> reverse both paused slidein;</span><br><span class="line"><span class="keyword">@keyframes</span> slidein &#123;&#125;</span><br></pre></td></tr></table></figure>
<u>不要和关键字重名，会优先匹配属性</u><br>@keyframes下会导致!important属性失效。</li>
<li><h3 id="动画属性，拥有较好的性能表现"><a href="#动画属性，拥有较好的性能表现" class="headerlink" title="动画属性，拥有较好的性能表现"></a>动画属性，拥有较好的性能表现</h3></li>
<li>transform属性，旋转，缩放，倾斜或平移给定元素，修改CSS视觉格式化模型的坐标空间来实现的。<ul>
<li>translate: 单独声明平移变换</li>
<li>scale / skew / rotate / matrix</li>
</ul>
</li>
<li>opacity</li>
<li>color</li>
</ul>
<blockquote>
<h2 id="CSS域处理器-Sass-Less-Postcss-Stylus"><a href="#CSS域处理器-Sass-Less-Postcss-Stylus" class="headerlink" title="CSS域处理器 Sass / Less / Postcss / Stylus"></a>CSS域处理器 Sass / Less / Postcss / Stylus</h2></blockquote>
<p><u>原理是将类CSS语言通过工具编译成浏览器可读的真正的CSS</u><br>是一种编程工具。允许开发人员使用编程语言编写可维护、可扩展的CSS，然后再编译成浏览器可读的CSS代码。</p>
<p>常用的功能点：<br>  嵌套 / 变量 / 循环语句 / 条件语句 / 自动前缀 / 单位转换 /mixin复用</p>
<p><u>为什么选择使用它</u></p>
<ul>
<li>提高效率，使用预处理器提供的功能大大提高编写CSS的效率</li>
<li>提高可维护性，将CSS分解成可重用的片段</li>
<li>提高代码可读性和组织性，嵌套规则可以更好地反映HTML标记的层次结构，使代码更易于阅读和维护</li>
<li>易于调试</li>
</ul>
<p><u>选择哪种预处理器取决于个人或团队的喜好跟项目需求</u></p>
<blockquote>
<h2 id="CSS层叠样式表（Cascading-Style-Sheets）"><a href="#CSS层叠样式表（Cascading-Style-Sheets）" class="headerlink" title="CSS层叠样式表（Cascading Style Sheets）"></a>CSS层叠样式表（Cascading Style Sheets）</h2></blockquote>
<p><u>如何理解</u><br>是一种样式表语言，用于描述HTML或XML文档的呈现。<br>层叠是CSS的样式冲突解决机制，是CSS的核心特性之一。<br>它是指当多个样式规则应用到同一个元素时，浏览器如何解决冲突并确定最终样式。</p>
<p>层叠规则基于几个因素：</p>
<ul>
<li>样式的重要性，标记为!important的样式优先级最高</li>
<li>选择器特定性，更具体的选择器优于普通选择器，比如ID选择器优于类选择器优于元素选择器</li>
<li>样式来源，其他所有规则相等情况下，后来的将覆盖先前的规则</li>
</ul>
<blockquote>
<h2 id="实现浏览器兼容性的CSS代码"><a href="#实现浏览器兼容性的CSS代码" class="headerlink" title="实现浏览器兼容性的CSS代码"></a>实现浏览器兼容性的CSS代码</h2></blockquote>
<ul>
<li>使用浏览器特定的前缀，如webkit- 、 moz- 、ms-、-o- 等<ul>
<li>在编写代码时可以利用一些插件自动补全前缀</li>
</ul>
</li>
<li>重置样式或规范化一些默认样式来消除差异</li>
<li>尽量使用所有浏览器都支持的CSS特性</li>
<li>可以在不同浏览器或设备上测试代码可行度以及定期调整和更新代码</li>
<li>媒体查询</li>
<li>使用polyfills补丁为旧浏览器提供它所不支持的新的功能<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// trunc:“截断”数字小数部分的函数</span></span><br><span class="line">  <span class="comment">// 如果没有这个函数</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Math</span>.<span class="property">trunc</span>) &#123; </span><br><span class="line">  <span class="title class_">Math</span>.<span class="property">trunc</span> = <span class="keyword">function</span>(<span class="params">number</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> number &lt; <span class="number">0</span> ? <span class="title class_">Math</span>.<span class="title function_">ceil</span>(number) : <span class="title class_">Math</span>.<span class="title function_">floor</span>(number);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>渐进增强和优雅降级，针对最新浏览器开发，但也逐步向下兼容对旧版浏览器的支持或提供简化体验</li>
<li>使用CSS Hack，但不太推荐</li>
</ul>
<blockquote>
<h2 id="响应式设计和自适应设计"><a href="#响应式设计和自适应设计" class="headerlink" title="响应式设计和自适应设计"></a>响应式设计和自适应设计</h2></blockquote>
<p><u>都是为了优化在各种设备上的用户体验</u></p>
<ul>
<li>响应式设计使得网页在任何设备上都能提供舒适的用户体验，可以通过媒体查询或可变的网格系统和布局来实现。</li>
<li>自适应设计则是为特定的设备或屏幕尺寸创建特定的设计。在不同的设备上显示不同的布局。</li>
</ul>
<p><u>两者区别在于响应式根据屏幕大小来调整，通常只使用一套代码。而自适应则需要为不同屏幕尺寸创建不同的布局和代码。</u></p>
<ul>
<li>响应式图片可以用<ul>
<li>max-width</li>
<li>使用 <picture> 元素提供多个图像源，浏览器选择最优图像来展示</li>
<li>使用srcset属性指定一系列备选图像， sizes属性指定在不同视口宽度下该显示的尺寸</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="BEM（Block-Element-Modifier）"><a href="#BEM（Block-Element-Modifier）" class="headerlink" title="BEM（Block Element Modifier）"></a>BEM（Block Element Modifier）</h2></blockquote>
<ul>
<li>一种前端开发的命名约定，旨在提高代码的可维护性和可读性</li>
<li>将页面的组件块，组件内的子元素以及可能存在的状态或修饰符都统一进行命名<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;button__text&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;button__icon button__icon--right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>作用是：<ul>
<li>清晰的命名规范</li>
<li>提高可维护性</li>
<li>减少样式冲突</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="零散知识点"><a href="#零散知识点" class="headerlink" title="零散知识点"></a>零散知识点</h2></blockquote>
<ul>
<li>在移动端上，当你用overflow-y:scorll属性时，发现滚动的效果很慢很卡顿<ul>
<li>这时候可以使用<u>-webkit-overflow-scrolling: touch</u>属性，让滚动条产生滚动回弹的效果，就像ios原生的滚动条一样流畅</li>
</ul>
</li>
<li>浏览器通常默认16px<ul>
<li>Font-size: 62.5%; 16px * 0.625 = 10px; 1rem = 10px; </li>
<li>设百分比，用具体像素值不能<strong>响应式改变</strong></li>
</ul>
</li>
<li>Rotate属性 <ul>
<li>turn 90deg = 100grad = 0.25turn ≈ 1.570796326794897rad （rad弧度）</li>
<li>1turn = 顺时针一圈</li>
</ul>
</li>
<li>FC 格式化上下文 (formatting context)<ul>
<li>常见的有： BFC (块级block) / IFC (行级inline) / GFC (网格布局gridLayout)  / FFC (自适应flex)</li>
</ul>
</li>
<li>渐变效果用来创建平滑过渡色彩的技术，可以用在背景、边框、文本等多种CSS属性中<ul>
<li>线性渐变linear-gradient 一个点到另一个点的过程中逐渐改变颜色</li>
<li>径向渐变radial-gradient 从一个圆形区域向外扩散，逐渐改变颜色</li>
</ul>
</li>
<li>touch-action用于设置触摸屏用户如何操纵元素的区域 (如浏览器内置的缩放功能)</li>
</ul>
<hr>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote>
<p>CSS 雪碧图 (CSS Sprites)<br>是一种优化网页性能的技术，通过将多个小图标或图像合并到一张大图中，然后通过 CSS 来显示图像的不同部分。这种方法减少了 HTTP 请求的数量，从而加快了网页的加载速度。</p>
</blockquote>
<blockquote>
<p>用纯css画一个三角形</p>
</blockquote>
<p>即元素宽高都设为0，设置边框样式<br>如果是正三角，就设底边框颜色，其他边框设为透明</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">80px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">90px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>画一个3d正方体</p>
</blockquote>
<ul>
<li>perspective: 指定了观察者与 z=0 平面的距离，使具有三维位置变换的元素产生透视效果</li>
<li>transform-style: 设置元素的子元素是位于3D空间中还是平面中 flat / preserve-3d</li>
<li>backface-visibility: 指定当元素背面朝向观察者时是否可见 visible / hidden</li>
</ul>
<blockquote>
<p>html语义化优点<br>语义化的html是指使用明确含义的标签来描述网页内容的结构和用途，使用语义化能提供更多的上下文信息，使得浏览器、开发者和搜索引擎能更好地理解和处理网页内容</p>
</blockquote>
<ul>
<li>提升了网页的可访问性<ul>
<li>语义化标签如 &lt;header&gt;、&lt;nav&gt;、&lt;main&gt; 等可以帮助屏幕阅读器更准确地解析，帮助视障用户更好理解和导航页面</li>
</ul>
</li>
<li>确保在不同设备和浏览器上的一致性，提升用户体验</li>
<li>代码可读性和可维护性<ul>
<li>结构清晰，文档清晰，方便编写和维护</li>
<li>减少样式依赖</li>
<li>更易团队合作</li>
</ul>
</li>
<li>搜索引擎优化（SEO）<ul>
<li>更好地理解网页内容和主题，提高在搜索结果中的排名</li>
</ul>
</li>
<li>兼容未来的标准</li>
</ul>
<blockquote>
<p>&lt;doctype&gt;标签的作用</p>
</blockquote>
<ul>
<li>用于声明文档类型和版本，确保浏览器能按照正常的标准解析和渲染页面，从而保证网页兼容性和一致性</li>
<li>标准模式、怪异模式（浏览器会以向后兼容的方式解析和渲染网页）</li>
</ul>

  </div>
</article>

        
        
      </div>
      <footer class="footer">
    <div class="footer-content">
        <p>&copy; 2025 蘑菇小记</p>
        <p class="copyright">All rights reserved.</p>
    </div>
</footer>
    </div>
    <button id="back-to-top" title="回到顶部">↑</button>
  </body>
</html>
